---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Управляющие конструкции

Lua предоставляет небольшой и традиционный набор управляющих структур: if для условного выполнения, а while, repeat и for для итерации. Все управляющие структуры обладают явным завершающим элементом: end завершает if, for и while, а until завершает repeat.

## if then else

Оператор if проверяет свое условие и в зависимости от результата выполняет одну из своих частей, then или else. Часть с else является необязательной.

```lua
if a < 0 then a = 0 end

if a < b then return a else return b end

if line > MAXLINES then
    showpage()
    line = 0
end
```

Для записи вложенных операторов if вы можете использовать elseif. Это аналогично else, за которым следует if, но при этом не возникает необходимости в нескольких end:&#x20;

```lua
if op == "+" then
    r = a + b
elseif op == "-" then
    r = a - b
elseif op == "*" then
    r = a*b
elseif op == "/" then
    r = a/b
else
    error("invalid operation")
end
```

Поскольку в Lua нет оператора switch, такие конструкции довольно распространены.

## while

Оператор while повторяет свое тело до тех пор, пока условие истинно. Как обычно, Lua сперва проверяет условие while; если оно ложно, то цикл завершается; в противном случае Lua выполняет тело цикла и повторяет данный процесс.

```lua
local i = 1
while a[i] do
    print(a[i])
    i = i + 1
end
```

## repeat

Оператор repeat–until повторяет свое тело до тех пор, пока условие не станет истинным. Данный оператор производит проверку условия после выполнения тела, поэтому тело цикла будет выполнено хотя бы один раз.

```lua
-- печатает первую непустую введенную строку
repeat
    line = io.read()
until line ~= ""
print(line)
```



{% hint style="warning" %}
В отличие от многих других языков, в Lua условие входит в область видимости локальной переменной, объявленной внутри цикла:

```lua
local sqr = x/2
repeat
sqr = (sqr + x/sqr)/2
local error = math.abs(sqr^2 - x)
until error < x/10000 -- local 'error' still visible here
```
{% endhint %}

## for

Оператор for существует в двух вариантах: числовой for и общий for. У общего и числового циклов есть два одинаковых свойства: переменные цикла локальны для тела цикла, и вы никогда не должны присваивать им какие-либо значения.

### Числовой for

Числовой for имеет следующий синтаксис:

```lua
for var = exp1, exp2, exp3 do
    <что-либо>
end
```

Этот цикл будет выполнять что-либо для каждого значения var от exp1 до ехр2, используя ехр3 как шаг для увеличения var. Это третье выражение необязательно; когда оно отсутствует, Lua считает значение шага равным 1. В качестве типичных примеров можно привести:

```lua
for i = 1, f(x) do print(i) end

for i = 10, 1, -1 do print(i) end
```

{% hint style="info" %}
**Тонкости числового for**

Во-первых, все три выражения вычисляются только один раз, перед началом цикла. Скажем, в нашем первом примере Lua вызовет f(х) всего один раз. Во-вторых, управляющая переменная является локальной переменной, автоматически объявляемой оператором for, и она видна лишь внутри цикла.&#x20;

Типичная ошибка — полагать, что эта переменная все еще существует после окончания цикла:

```lua
for i = 1, 10 do print(i) end
max = i -- вероятно, неправильно! здесь 'i' глобальная
```

В-третьих, вы никогда не должны изменять значение управляющей переменной: эффект подобных изменений не предсказуем. Если вы хотите закончить цикл for до его нормального завершения, используйте break.
{% endhint %}

### Общий for

Общий for обходит все значения, возвращаемые итерирующей функцией:

```lua
-- печатает все значения таблицы 't'
for k, v in pairs(t) do print(k, v) end
```

{% hint style="info" %}
Этот пример использует pairs, удобную итерирующую функцию для перебора таблицы, предоставляемую базовой библиотекой Lua. На каждом шаге этого цикла k получает ключ, a v получает значение, связанное с этим ключом
{% endhint %}

С подходящими итераторами вы можете в легкочитаемой форме перебрать практически все, что угодно. Стандартные библиотеки предоставляют несколько итераторов, позволяющих нам перебирать строки файла (io.lines), пары таблицы (pairs), элементы последовательности (ipars), слова внутри строки (string.gmatch) и т.д.

{% hint style="info" %}
Можно писать и собственные итераторы! Подробнее об этом на странице <mark style="color:red;">TODO</mark>
{% endhint %}

## break

Оператор break прерывает цикл (while, repeat или for), в теле которого встречается. После прерывания программа продолжит выполнение с точки, следующей сразу после прерванного цикла.

```lua
for i = 1,#a do -- ищем в массиве отрицательное значение
   if a[i] < 0 then -- если найдено...
      index = i -- сохраняем индекс найденного значения...
      break -- и прерываем цикл
   end
end
```

## return

Оператор return возвращает результаты из функции, если они есть, или просто завершает ее.

```lua
function f(x)
   return x^2
end
```

{% hint style="info" %}
В конце каждой функции присутствует неявный возврат из нее, поэтому вам необязательно его использовать, если ваша функция завершается естественным образом, не возвращая никакого значения.
{% endhint %}

{% hint style="danger" %}
Оператор return может быть только последними оператором блока (иначе следующие за ним операторы никогда не выполнятся). Если действительно необходимо вставить return в середину блока, например, чтобы временно отключить выполнение части кода функции, этот оператор следует заключить в свой блок do–end.

```lua
function f1 (x)
   return -- НЕВЕРНО!
   <другие операторы>
end

function f2 (x)
   do return end -- Правильно
   <другие операторы>
end
```
{% endhint %}

## goto

Оператор goto может легко превратить ваш код в спагетти код. Так что по возможности старайтесь его не использовать.

Синтаксис goto (TODO дописать):

<pre class="language-lua"><code class="lang-lua">while some_condition do
<strong>    ::redo::
</strong>    if some_other_condition then goto continue
    else if yet_another_condition then goto redo
    end
    &#x3C;какой-нибудь код>
    ::continue::
end
</code></pre>



Оператор goto передает выполнение программы соответствующей метке. Насчет goto были долгие обсуждения, и некоторые люди даже сейчас считают, что эти операторы вредны для языков программирования и должны быть из них исключены. Однако, ряд существующих языков предлагает goto совершенно обоснованно. Данные операторы являются мощным механизмом, который, будучи использованным с осторожностью, способен лишь улучшить качество вашего кода. В Lua синтаксис для оператора goto вполне традиционный: это зарезервированное слово goto, за которым следует имя метки, которое может быть любым допустимым идентификатором. Синтаксис для метки немного более запутанный: два двоеточия, за которыми следует имя метки, после которого идут еще два двоеточия, например, как в ::name::. Эта сложность намеренная, чтобы заставить программиста дважды подумать, прежде чем использовать goto. Lua накладывает некоторые ограничения на то, куда вы можете прыгнуть при помощи goto. Во-первых, метки следуют обычным правилам видимости, поэтому вы не можете прыгнуть внутрь блока (поскольку метка внутри блока невидима за его пределами). Во-вторых, вы не можете выпрыгнуть из функции. (Обратите внимание, что первое правило уже исключает возможность прыгнуть внутрь функции.) Втретьих, вы не можете прыгнуть внутрь области видимости локальной переменной. Типичным и хорошо зарекомендовавшим себя применением goto является моделирование некоторой конструкции, которую вы узнали из другого языка, но которая отсутствует в Lua, например continue, многоуровневые break, redo и т. п. Оператор continue — это просто безусловный переход к метке в конце блока цикла; оператор redo осуществляет переход к началу блока

{% hint style="warning" %}

{% endhint %}

Полезной деталью в спецификации Lua является то, что область видимости локальной переменной заканчивается на первом непустом операторе блока, в котором эта переменная определена; метки считаются пустыми операторами. Чтобы увидеть полезность данной детали, рассмотрим следующий фрагмент кода: while some\_condition do if some\_other\_condition then goto continue end local var = something <какой-нибудь код> ::continue:: end Вы можете подумать, что этот goto перепрыгивает в область видимости переменной var. Однако, метка continue находится после последнего непустого оператора блока, и поэтому не в области видимости переменной var. Оператор goto также полезен при написании конечных автоматов (машин состояний). В качестве примера листинг 4.1 показывает программу, проверяющую, содержит ли ее ввод четное количество нулей. Существуют лучшие способы написания этой специфической программы, но данный подход удобен, если вы хотите автоматически перевести конечный автомат в код Lua (подумайте о динамической генерации кода).













## Полезное

{% hint style="success" %}
В Lua поиск применяется не столь часто. В некоторых случаях лучше использовать следующий подход:

Допустим, у вас есть есть таблица с названиями дней недели:

```lua
days = {"Sunday", "Monday", "Tuesday", "Wednesday",
"Thursday", "Friday", "Saturday"}
```

И вы хотите перевести название дня в его номер по счету в неделе. Вы можете использовать поиск, но лучше построить обратную таблицу, в которой названия дней используются как индексы, а номера используются как значения.

```lua
revDays = {["Sunday"] = 1, ["Monday"] = 2,
["Tuesday"] = 3, ["Wednesday"] = 4,
["Thursday"] = 5, ["Friday"] = 6,
["Saturday"] = 7}
```

Тогда все, что вам нужно, чтобы найти номер дня по названию, — это обратиться по индексу этой обратной таблицы:

```lua
x = "Tuesday"
print(revDays[x]) --> 3
```

Такое обращение будет быстрее чем каждый раз пробегать по таблице поиском.

И мы можем, вместо того чтобы задавать такую таблицу вручную, создать ее автоматически!

```lua
revDays = {}
for k,v in pairs(days) do
    revDays[v] = k
end
```
{% endhint %}
