---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Типы и значения

В Lua существует 8 базовых типов: nil, boolean, number, string, table, function, userdata, thread

### Отсутствие значения (nil)

Основная задача типа состоит в том, чтобы отличаться от всех остальных значений. Lua использует nil как нечто, не являющееся значением, чтобы изобразить отсутствие значения.&#x20;

### Логические значение (boolean)

Тип обладает двумя значениями - <mark style="color:red;">true</mark> и <mark style="color:red;">false</mark>, которые представляют традиционные логические (булевы) значения.

В Lua логическое условие может быть представлено любым значением. Проверки условий считают nil и false ложными, а все прочие значения истинными. (к примеру, ноль и пустая строка будут считаться истинными значениями)

### Числа (number)

Тип number представляет вещественные числа, т.е. числа двойной точности с плавающей точкой (тип double).&#x20;

{% hint style="warning" %}
В Lua нет целочисленного типа. Но проблем с операциями на целыми числами нет (вплоть до 2^53). Никаких ошибок округления с целыми числами в данном диапазоне не происходит. Но вот с дробными числами нужно знать следующий нюанс: если число не имеет точного представления в двоичном виде (например 12.7) то число будет округлено. И выражение "12.7 - 20 + 7.3" не будет равно нулю.

```lua
print(12.7 - 20 + 7.3)    --> -8.8817841970013e-16
```
{% endhint %}

В Lua можно записывать числа в десятеричной и шестнадцатеричной системе:

```
4    0.4    4.57e-3    0.3e12    5E+20

0xff (255)    0x1A3 (419)    0x0.2 (0.125)    0x1p-1 (0.5)
```

### Строки (string)

Тип string в Lua имеет обычный смысл: последовательность символов.

Строки в Lua являются неизменяемыми значениями. При изменение символа внутри строки создается новая строка с необходимыми изменениями.

Строки в Lua подвержены автоматическому управлению памятью, как и любые другие объекты в Lua (таблицы, функции и т.д.). Это значит, что вам не нужно беспокоиться о выделении и освобождении строк - этим за вас займется Lua. Строка можно состоять из любого количества символов.

Чтобы получить длину строки - используйте префиксную операцию "#" (операция длины)

```lua
a = "DUCK"
print(#a)                --> 4
print(#"good\0bye")      --> 8
```

Определить строку можно с помощью одинарных или двойных кавычек. Единственное отличие - внутри одного вида кавычек вы можете использовать другой, не применяя экранирование символов.&#x20;

{% hint style="info" %}
Большинство программистов всегда использует кавычки одного вида для одних и тех же видов строк, где "виды" строк зависят от программы.
{% endhint %}

В Lua также можно задать строки следующим образом:

```lua
page = [[
<html>
    <head>
        <title>An HTML Page</title>
    </head>
</html>
]]
```

Определение строки с помощью двойных квадратных скобок позволяет игнорировать все escape-последовательности, т. е. строка создаётся полностью так, как описана (учитываются символы табуляции и переноса).

{% hint style="info" %}
В случае если вам нужно записать в строку данные что содержат "]]",

```lua
a = b[c[i]]    -- пример
```

тогда можно использовать скобки со произвольным количеством знаков равенства между ними:

```lua
someString = [===[
a = b[c[i]]
print(a)
]===]
```
{% endhint %}

### Таблицы (table)

Тип table представляет ассоциативные массивы. Ассоциативный массив - это массив, который может быть индексирован не только числами, но и строками и любым другим значением языка, кроме nil.

Таблицы являются главным (и единственным) механизмом структурирования данных в Lua, притом очень эффективным. Мы используем для представления обычных массивов, множеств, записей и других структур данных простым, однородным и эффективным способом. Также Lua использует таблицы для представления пакетов и объектов. Когда мы пишем io.read, мы думаем о "функции read из модуля io". Для Lua это выражение означает "индексировать таблицу io, используя строку read в качестве ключа".

Таблицы в Lua являются ни значениями, ни переменными - они _объекты._ Вы можете рассматривать таблицу как динамически выделяемый объект. Ваша программа работает только с ссылками (указателями) на них. Lua никогда не прибегает к скрытому копированию или созданию новых таблиц.&#x20;

Таблицы создаются с помощью выражения-конструктора:

```lua
a = {}    -- создает таблицу и сохраняет ссылку на нее в 'a'
k = "x"
a[k] = 10    -- новая запись с ключом "x" и значением 10
a[20] = "great"    -- новая запись с ключом 20 и значением "great"
print(a["x"])    --> 10
k = 20
print(a[k])    --> great
a["x"] = a["x"] + 1     -- инкрементирует запись "x"
print(a["x"])    --> 11
```

Таблица всегда анонимна. Не существует постоянной связи между переменной, которая хранит таблицу и самой таблицей:

```lua
a = {}
a["x"] = 10
b = a            -- 'b' ссылается на ту же таблицу, что и 'a'
print(b["x"])    --> 10
b["x"] = 20
print(a["x"])    --> 20
a = nil          -- лишь 'b' по-прежнему ссылается на ту таблицу
b = nil          -- ссылок на таблицу не осталось
```

Когда в программе больше не остается ссылок на таблицу, сборщик мусора Lua со временем удалит эту таблицу, чтобы повторно использовать ее память.

Каждая таблица может хранить значения с разными типами индексов и растет по мере добавления новых записей.

Поля таблицы возвращают nil, когда не инициализированы. Вы можете присвоить nil полю таблицы чтобы удалить его.

Вы можете использовать имя поля таблицы как индекс и обращаться к ним следующим образом:

```lua
a = {}
a["x"] = 10
print(a.x)    -- то же, что и print(a["x"])
```

{% hint style="warning" %}
Типичная ошибка новичков - спутать a.x с a\[x]. Первая форма соответствует a\["x"], а вторая означает, что таблица индексирована при помощи значения переменной x.

```lua
a = {}
x = "y"
a[x] = 10
print(a[x])    --> 10
print(a.x)     --> nil
print(a.y)     --> 10
```
{% endhint %}

Чтобы представить традиционный массив или список, просто используйте таблицу с целочисленными ключами. Нет ни способа, ни необходимости объявлять размер. Вы всего лишь инициализируете те элементы, которые вам нужны:

```lua
-- считывает 10 строк, сохраняя их в таблице
a = {}
for i = 1, 10 do
    a[i] = io.read()
end
```

{% hint style="info" %}
Поскольку вы можете индексировать таблицу любым значением, вы можете начинать индексы массива с любого числа, которое вам нравится. Однако в Lua принято начинать массивы с единицы (а не с нуля). Некоторые средства Lua придерживаются этого соглашения и для того чтобы с ними корректно работать нужно придерживаться этого правила.
{% endhint %}

Когда вы работаете со списком, обычно вам нужно знать его длину. Она может быть константой или хранится где-то еще. Часто мы храним длину списка в нечисловом поле таблицы (например поле "n").

В Lua существует операция длины "#". Она работает также для таблиц, которые хранят последовательности (последовательность в Lua - это таблица с целочисленными ключами начиная с 1. В последовательности не должно быть дыр, т.е. элементов с значением nil). Операция длины считает элементы начиная с 1 до первого значения, которое равно nil.

```lua
a = {}
a[1] = "A"
a[2] = true
a[3] = 354

print(#a)    --> 3

b = {}
b[1] = 7
b[2] = "str"
b[1000] = true

print(#b)    --> 2
```

### Функции (function)

Функции (тип function) являются в Lua значениями первого класса: программы могут хранить функции в переменных, передавать функции как аргументы для других функций и возвращать  функции как результаты.

Lua может вызывать функции написанные на Lua и функции написанные других языках (например функции из Lua модуля, который написан на C).&#x20;

### Пользовательские данные (userdata)

Тип userdata позволяет запоминать произвольные данные созданные прикладной программой или сторонней библиотекой (написанной на других языках) в переменных Lua. У него нет предопределенных операций в Lua, за исключением присваивания и проверки на равенство.&#x20;

### Потоки (thread)

Соответствует потоку выполнения. Эти потоки никаким образом не связаны с операционной системой и поддерживаются исключительно средствами самого Lua.

### Полезное

{% hint style="info" %}
**Приведение типов**

Lua обеспечивает автоматическое преобразование между числами и строками во время выполнения программ. Строка преобразуется в число в случае когда к ней применяется числовая операция или если она используется в качестве параметра в функции, где ожидается число. Число преобразуется в строку там, где ожидается строка.

```lua
print(5 + "10")     --> 15 (number)
print(5 .. "10")    --> 510 (string)
```

<mark style="color:red;">Лучше не рассчитывать на автоматическое приведение данных типов. Используйте явное приведение типов с помощью функций tonumber(...) и tostring(...)</mark>

\
Правила преобразования чисел в строки (и наоборот) при сравнениях не работают, т. е. выражение "0" == 0 даёт в результате <mark style="color:red;">false</mark>.
{% endhint %}

{% hint style="info" %}
#### Как в Lua задать тип переменной

Lua не предусматривает явного задания типа переменной. Тип переменной устанавливается в момент присвоения переменной значения.

```lua
a = 123 -- переменная a имеет тип number
a = "123" -- теперь переменная a имеет тип string
a = true -- теперь переменная a имеет тип boolean
a = {} -- теперь переменная a имеет тип table
```
{% endhint %}

{% hint style="warning" %}
Переменные типа table, function, thread и userdata не содержат самих данных, а хранят ссылки на соответствующие объекты. При присваивании, передачи в функцию в качестве аргумента и возвращении из функции в качестве результата копирования объектов не происходит, копируются только ссылки на них.

```lua
a = {} -- создаем таблицу. В переменную a помещается ссылка на таблицу
b = a -- переменная b ссылается на ту же таблицу, что и a
a[1] = 10 -- элементу таблицы с индексом 1 присвоено значение 10
MsgBox(b[1]) --> '10'
b[1] = 20 
MsgBox(a[1]) --> '20'
```

Остальные данные являются непосредственными значениями.
{% endhint %}

{% hint style="info" %}
#### Как в Lua получить тип переменной

Тип значения, сохранённого в переменной, можно выяснить при помощи стандартной функции **type**. Эта функция возвращает строку, содержащую название типа («nil», «number», «string», «boolean», «table», «function», «thread», «userdata»)

```lua
print(type("DUCK"))  --> string
print(type(123))     --> number
print(type(type))    --> function
```
{% endhint %}
