---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Управляющие конструкции

Lua предоставляет небольшой и традиционный набор управляющих структур: if для условного выполнения, а while, repeat и for для итерации. Все управляющие структуры обладают явным завершающим элементом: end завершает if, for и while, а until завершает repeat.

## if then else

Оператор if проверяет свое условие и в зависимости от результата выполняет одну из своих частей, then или else. Часть с else является необязательной.

```lua
if a < 0 then a = 0 end

if a < b then return a else return b end

if line > MAXLINES then
    showpage()
    line = 0
end
```

Для записи вложенных операторов if вы можете использовать elseif. Это аналогично else, за которым следует if, но при этом не возникает необходимости в нескольких end:&#x20;

```lua
if op == "+" then
    r = a + b
elseif op == "-" then
    r = a - b
elseif op == "*" then
    r = a*b
elseif op == "/" then
    r = a/b
else
    error("invalid operation")
end
```

Поскольку в Lua нет оператора switch, такие конструкции довольно распространены.

## while

Оператор while повторяет свое тело до тех пор, пока условие истинно. Как обычно, Lua сперва проверяет условие while; если оно ложно, то цикл завершается; в противном случае Lua выполняет тело цикла и повторяет данный процесс.

```lua
local i = 1
while a[i] do
    print(a[i])
    i = i + 1
end
```

## repeat

Оператор repeat–until повторяет свое тело до тех пор, пока условие не станет истинным. Данный оператор производит проверку условия после выполнения тела, поэтому тело цикла будет выполнено хотя бы один раз.

```lua
-- печатает первую непустую введенную строку
repeat
    line = io.read()
until line ~= ""
print(line)
```



{% hint style="warning" %}
В отличие от многих других языков, в Lua условие входит в область видимости локальной переменной, объявленной внутри цикла:

```lua
local sqr = x/2
repeat
sqr = (sqr + x/sqr)/2
local error = math.abs(sqr^2 - x)
until error < x/10000 -- local 'error' still visible here
```
{% endhint %}

## for

Оператор for существует в двух вариантах: числовой for и общий for. У общего и числового циклов есть два одинаковых свойства: переменные цикла локальны для тела цикла, и вы никогда не должны присваивать им какие-либо значения.

### Числовой for

Числовой for имеет следующий синтаксис:

```lua
for var = exp1, exp2, exp3 do
    <что-либо>
end
```

Этот цикл будет выполнять что-либо для каждого значения var от exp1 до ехр2, используя ехр3 как шаг для увеличения var. Это третье выражение необязательно; когда оно отсутствует, Lua считает значение шага равным 1. В качестве типичных примеров можно привести:

```lua
for i = 1, f(x) do print(i) end

for i = 10, 1, -1 do print(i) end
```

{% hint style="info" %}
**Тонкости числового for**

Во-первых, все три выражения вычисляются только один раз, перед началом цикла. Скажем, в нашем первом примере Lua вызовет f(х) всего один раз. Во-вторых, управляющая переменная является локальной переменной, автоматически объявляемой оператором for, и она видна лишь внутри цикла.&#x20;

Типичная ошибка — полагать, что эта переменная все еще существует после окончания цикла:

```lua
for i = 1, 10 do print(i) end
max = i -- вероятно, неправильно! здесь 'i' глобальная
```

В-третьих, вы никогда не должны изменять значение управляющей переменной: эффект подобных изменений не предсказуем. Если вы хотите закончить цикл for до его нормального завершения, используйте break.
{% endhint %}

### Общий for

Общий for обходит все значения, возвращаемые итерирующей функцией:

```lua
-- печатает все значения таблицы 't'
for k, v in pairs(t) do print(k, v) end
```

{% hint style="info" %}
Этот пример использует pairs, удобную итерирующую функцию для перебора таблицы, предоставляемую базовой библиотекой Lua. На каждом шаге этого цикла k получает ключ, a v получает значение, связанное с этим ключом
{% endhint %}

С подходящими итераторами вы можете в легкочитаемой форме перебрать практически все, что угодно. Стандартные библиотеки предоставляют несколько итераторов, позволяющих нам перебирать строки файла (io.lines), пары таблицы (pairs), элементы последовательности (ipars), слова внутри строки (string.gmatch) и т.д.

{% hint style="info" %}
Можно писать и собственные итераторы! Подробнее об этом на странице <mark style="color:red;">TODO</mark>
{% endhint %}

## break

Оператор break прерывает цикл (while, repeat или for), в теле которого встречается. После прерывания программа продолжит выполнение с точки, следующей сразу после прерванного цикла.

```lua
for i = 1,#a do -- ищем в массиве отрицательное значение
   if a[i] < 0 then -- если найдено...
      index = i -- сохраняем индекс найденного значения...
      break -- и прерываем цикл
   end
end
```

## return

Оператор return возвращает результаты из функции, если они есть, или просто завершает ее.

```lua
function f(x)
   return x^2
end
```

{% hint style="info" %}
В конце каждой функции присутствует неявный возврат из нее, поэтому вам необязательно его использовать, если ваша функция завершается естественным образом, не возвращая никакого значения.
{% endhint %}

{% hint style="danger" %}
Оператор return может быть только последними оператором блока (иначе следующие за ним операторы никогда не выполнятся). Если действительно необходимо вставить return в середину блока, например, чтобы временно отключить выполнение части кода функции, этот оператор следует заключить в свой блок do–end.

```lua
function f1 (x)
   return -- НЕВЕРНО!
   <другие операторы>
end

function f2 (x)
   do return end -- Правильно
   <другие операторы>
end
```
{% endhint %}













## Полезное

{% hint style="success" %}
В Lua поиск применяется не столь часто. В некоторых случаях лучше использовать следующий подход:

Допустим, у вас есть есть таблица с названиями дней недели:

```lua
days = {"Sunday", "Monday", "Tuesday", "Wednesday",
"Thursday", "Friday", "Saturday"}
```

И вы хотите перевести название дня в его номер по счету в неделе. Вы можете использовать поиск, но лучше построить обратную таблицу, в которой названия дней используются как индексы, а номера используются как значения.

```lua
revDays = {["Sunday"] = 1, ["Monday"] = 2,
["Tuesday"] = 3, ["Wednesday"] = 4,
["Thursday"] = 5, ["Friday"] = 6,
["Saturday"] = 7}
```

Тогда все, что вам нужно, чтобы найти номер дня по названию, — это обратиться по индексу этой обратной таблицы:

```lua
x = "Tuesday"
print(revDays[x]) --> 3
```

Такое обращение будет быстрее чем каждый раз пробегать по таблице поиском.

И мы можем, вместо того чтобы задавать такую таблицу вручную, создать ее автоматически!

```lua
revDays = {}
for k,v in pairs(days) do
    revDays[v] = k
end
```
{% endhint %}
