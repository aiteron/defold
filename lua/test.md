---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# TEST

```lua
print("Hello World!")
```

## Начало работы

? Что такое луа

! Инфо о том где можно потестить примеры из гайда

### Переменные

! В луа не нужен разделитель между идущими подряд операторами. (Но вы можете их использовать. Например удобно использовать их для разделения двух или более операторов записанных в одной строке)

```lua
a = 1
b = a*2

c = 2 + 2; d = c / 2
```

* Идентификаторы (имена) в Lua могут быть любой последовательностью из букв (A-Z и a-z), цифр и символов подчеркивания, не начинающейся с цифры. Например:

```
i    j    i10    _ij    aSomewhatLongName    _INPUT
```

! Лучше избегать индентификаторов, начинающихся с символа подчеркивания, за которым следует одна или несколько заглавных букв (например \_VERSION). Они зарезервированы в Луа для особых целей.

Совет: для переменных, значения которых не особо важно, удобно использовать \_ (одиночный символ подчеркивания)

Зарезервированные слова (их нельзя использовать в качестве идентификаторов):

```
and      break    do      else   elseif
end      false    goto    for    function
if       in       local   nil    not
or       repeat   return  then   true
until    while
```

Lua учитывает регистр букв: and - зарезервированное слово, но And и AND - это два отличных от него и друг от друга идентификатора.

Глобальным переменным не нужны объявления. Их можно сразу использовать. Обращение к неинициализированной переменной не является ошибкой - вы всего лишь получите значение nil в качестве результата:

```lua
print(b)    --> nil
b = 10
print(b)    --> 10
```

Также переменной вновь присвоить значение nil. В таком случае Луа поведет себя так, как если бы эта переменная никогда не использовалась. (После данного присваивания Луа может со временем высвободить память, выделенную под эту переменную.

```
b = nil
print(b)    --> nil
```

### Типы и значения

Луа - язык с динамической типизацией. В нем нет определений типов - каждое значение содержит в себе свой собственный тип (???)

_В Луа существует 8 базовых типов:_

#### Отсутствие значения (nil)

Основная задача типа состоит в том, чтобы отличаться от всех остальных значений. Луа использует nil как нечто, не являющееся значением, чтобы изобразить отсутствие значения.&#x20;

#### Логические значение (boolean)

Тип обладает двумя значениями - <mark style="color:red;">true</mark> и <mark style="color:red;">false</mark>, которые представляют традиционные логические (булевы) значения.

В луа логическое условие может быть представлено любым значением. Проверки условий считают nil и false ложными, а все прочие значения истинными. (к примеру, ноль и пустая строка будут считаться истинными значениями)

#### Числа (number)

Тип number представляет вещественные числа, т.е. числа двойной точности с плавующей точкой (тип double). В луа нет целочисленного типа.

! Проблем с операциями на целыми числами нет (вплоть до 2^53). Никаких ошибок округления с целыми числами в данном диапазоне не происходит. Но вот с дробными числами нужно знать следующий нюанс: если число не имеет точного представления в двоичном виде (например 12.7) то число будет округлено. И выражение "12.7 - 20 + 7.3" не будет равно нулю.

```
print(12.7 - 20 + 7.3)    --> -8.8817841970013e-16
```

В Луа можно записывать числа в десятеричной и шестнадцатеричной системе:

```
4    0.4    4.57e-3    0.3e12    5E+20

0xff (255)    0x1A3 (419)    0x0.2 (0.125)    0x1p-1 (0.5)
```

#### Строки (string)

Тип string в Луа имеет обычный смысл: последовательность символов.

В виде строк можно хранить любые бинарные данные.

Строки в Луа являются неизменяемыми значениями. При изменение символа внутри строки создается новая строка с необходимыми изменениями.

Строки в Луа подвержены автоматическому управлению памятью, как и любые другие объекты в Луа (таблицы, функции и т.д.). Это значит, что вам не нужно беспокоиться о выделении и освобождении строк - этим за вас займется Луа. Строка можно состоять из любого количества символов.

Чтобы получить длину строки - используйте префиксную операцию "#" (операция длины)

```
a = "DUCK"
print(#a)                --> 4
print(#"good\0bye")      --> 8
```

Определить строку можно с помощью одинарных или двойных кавычек. Единственное отличие - внутри одного вида кавычек вы можете использовать другой, не применяя экранирование символов.&#x20;

Пример экранированного символа переноса строки ("\n"):

```
s = "First line\nSecond line"
print(s)    --> First line
                Second line
```

! Большинство программистов всегда использует кавычки одного вида для одних и тех же видов строк, где "виды" строк зависят от программы.

В луа можно задать длинные строки следующим образом:

```
page = [[
<html>
    <head>
        <title>An HTML Page</title>
    </head>
</html>
]]

```

\-- В случае если вам нужно записать в строку данные что содержат "]]" (например a = b\[c\[i]]), тогда можно использовать скобки со произвольным количеством знаков равенства между ними. Также работает и многострочными комментариями! (удобно в случае когда нужно закомментировать большой кусок кода в котором уже есть многострочные комментарии)

```
-- СТРОКА
someString = [===[
a = b[c[i]]
print(a)
]===]

-- КОММЕНТАРИЙ
--[=[
print(a)
print(b)
--]=]
```

**Приведение типов**

Луа обеспечивает автоматическое преобразование между числами и строками во время выполнения программ. Строка преобразуется в число в случае когда к ней применяется числовая операция или если она используется в качестве параметра в функции, где ожидается число. Число преобразуется в строку там, где ожидается строка.

{% hint style="danger" %}
Лучше не рассчитывать на автоматическое приведение данных типов. Используйте явное приведение типов с помощью функций tonumber(...) и tostring(...)
{% endhint %}

#### Таблицы (table)

Тип table представляет ассоциативные массивы. Ассоциативный массив - это массив, который может быть индексирован не только числами, но и строками и любым другим значением языка, кроме nil.

Таблицы являются главным (и единственным) механизмом структурирования данных в Луа, притом очень эффективным. Мы используем для представления обычных массивов, множеств, записей и других структур данных простым, однородным и эффективным способом. Также луа использует таблицы для представления пакетов и объектов. Когда мы пишем io.read, мы думаем о "функции read из модуля io". Для Луа это выражение означает "индексировать таблицу io, используя строку read в качестве ключа".

Таблицы в луа являются ни значениями, ни переменными - они _объекты._ Вы можете рассматривать таблицу как динамически выделяемый объект. Ваша программа работает только с ссылками (указателями) на них. Луа никогда не прибегает к скрытому копированию или созданию новых таблиц.&#x20;

Таблицы создаются с помощью выражения-конструктора:

```lua
a = {}    -- создает таблицу и сохраняет ссылку на нее в 'a'
k = "x"
a[k] = 10    -- новая запись с ключом "x" и значением 10
a[20] = "great"    -- новая запись с ключом 20 и значением "great"
print(a["x"])    --> 10
k = 20
print(a[k])    --> great
a["x"] = a["x"] + 1     -- инкрементирует запись "x"
print(a["x"])    --> 11
```

Таблица всегда анонимна. Не существует постоянной связи между переменной, которая хранит таблицу и самой таблицей:

```lua
a = {}
a["x"] = 10
b = a            -- 'b' ссылается на ту же таблицу, что и 'a'
print(b["x"])    --> 10
b["x"] = 20
print(a["x"])    --> 20
a = nil          -- лишь 'b' по-прежнему ссылается на ту таблицу
b = nil          -- ссылок на таблицу не осталось
```

Когда в программе больше не остается ссылок на таблицу, сборщик мусора луа со временем удалит эту таблицу, чтобы повторно использовать ее память.

Каждая таблица может хранить значения с разными типами индексов и растет по мере добавления новых записей.

Поля таблицы возвращают nil, когда не инициализированы. Вы можете присвоить nil полю таблицы чтобы удалить его.

Вы можете использовать имя поля таблицы как индекс и обращаться к ним следующим образом:

```lua
a = {}
a["x"] = 10
print(a.x)    -- то же, что и print(a["x"])
```

































### Комментарии

```lua
a = 0 -- Однострочный комментарий

--[[
Пример многострочного комментария
a = 10
print(a)
--]]
```

{% hint style="info" %}
Многострочные комментарии удобны для комментирования кусков кода. При необходимости потом легко можно восстановить работоспособность кода просто добавив "-" (дефис) пере началом комментария:

```lua
---[[
print(10)
--]]
```
{% endhint %}











\------

* Lua - простой, расширяемый, переносимый и эффективный скриптовый язык
* Lua лучше всего работает в связке с основной программой. Например с Defold
* Lua хорош в этом: высокая степень независимости от аппаратного обеспечения, динамические структуры, отсутствие избыточности и легкость тестирования и отладки. Луа обладает безопасным окружением, автоматической управлением памятью и хорошими средствами для работы со строками и другими видами данных с динамически изменяемым размером.
* Одной из самых сильных сторон Луа является его расширяемость с помощью библиотек и модулей.
* Lua позволяет поддерживать подход для разработки ПО на основе компонентов, когда мы создаем приложение, связывая вместе существующие высокоуровневые компоненты. Язык позволяет использовать низкоуровневые сущности написанные на других языках и использовать их для создания новых высокоуровневых компонентов.
* Преимущества Луа перед другими скриптовыми языками:
  * Расширяемость. Возможности языка можно расширять как с помощью кода Луа, так и с помощью функционала написанного на других языках.
  * Простота. Луа - это простой и маленький язык. У него мало концепций (зато они эффективные).
  * Эффективность. Независимые тесты показывают, что луа является одним из самых быстрых среди скриптовых языков.
  * Переносимость. Луа можно запустить на очень большом количестве платформ (На всех, где поддерживается компилятор ANSI C).
*
