---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Функции

Функция в Lua является основным механизмом абстракции операторов и выражений. Проще говоря, функция - это специальная конструкция в языке которая позволяет объединить кусок кода, который выполняет определенную задачу. Это позволяет позднее использовать этот код произвольное количество раз (что позволяет избежать дублирования кода) и разделить код на достаточно простые и легко управляемые части.

### Как использовать функции

Функции можно поделить на 2 типа:&#x20;

1. Функции которые выполняют определенное задание и не возвращают значение (часто называемые процедурой или подпрограммой в других языках)&#x20;
2. Функции которые вычисляют и возвращают значение

В первом случае мы используем вызов функции как оператор:

```lua
print("DUCK")
```

Во втором случае мы можем использовать ее как выражение:

```lua
a = math.sin(3) + math.cos(10)
print(os.date())
```

{% hint style="info" %}
Когда программа вызывает функцию, управление программой передается вызываемой функции. Вызываемая функция выполняет определенную задачу, и когда выполняется оператор return или когда достигается конец ее функции, она возвращает управление программой обратно в основную программу.
{% endhint %}

### Определение функции

Традиционный синтаксис функции в Lua следующий:

```lua
function add(a)
    local sum = 0
    for i = 1, #a do
        sum = sum + a[i]
    end
    return sum
end
```

В этом синтаксисе определение функции содержит имя (add), список параметров и тело, которое является списком операторов.

#### Параметры функции

Параметры работают в точности как локальные переменные, проинициализированные значениями аргументов, которые были переданы вызову функции.

Вы можете вызвать функцию с числом аргументов, отличным от ее числа параметров. Lua приведет число аргументов к числу параметров: лишние аргументы отбрасываются, а если аргументов было меньше чем параметров, то лишние параметры получат nil.

Пример:

```lua
function f(a, b)
    print(a, b)
end

f(3)        --> 3 nil
f(3, 4)     --> 3 4
f(3, 4, 5)  --> 3 4
```

#### Переменное количество аргументов

В Lua можно создать функцию, которая будет принимать и корректно обрабатывать переменное количество аргументов. Для этого нужно написать (...) в списке параметров функции:

```lua
function add (...)
    local s = 0
    for i, v in ipairs({...}) do
        s = s + v
    end
    return s
end
print(add(3, 4, 10, 25, 12)) --> 54
print(add(2, 2)) --> 4
```

Получить доступ к переданным аргументам можно с помощью выражения (...). Оно ведет себя как функция&#x20;











#### Возврат значений из функции

В Lua функции могут возвращать любое количество значений (или не возвращать вовсе). В случае когда функция возвращает более одного значения, сохранить результат функции позволяет множественное присваивание.

Примеры:

```lua
function f()
    return "A"    -- 
end

function g()
    return "B", "C", "D"
end

function h()
    print("DUCK")
end

a = f()
b, c, d = g()
h()                  --> DUCK
print(a, b, c, d)    --> A B C D
```

!! Можно использовать return чтобы раньше закончить выполнение функции. Также можно return не указывать.

!! Lua всегда приводит количество результатов функции к обстоятельствам ее вызова. Когда мы вызываем функцию как оператор, Lua отбрасывает все результаты функции. Когда мы используем вызов как выражение, Lua оставляет только первый результат. Мы получаем все результаты лишь тогда, когда вызов является последним (или единственным) выражением в списке выражений. В Lua эти списки встречаются в четырех конструкциях: множественные присваивания, аргументы в вызовах функций, конструкторы таблиц и операторы return. Для иллюстрации всех этих случаев допустим, что у нас есть такие определения для наших последующих примеров:

```lua
function foo0() end -- возвращает 0 значений
function foo1() return "a" end -- возвращает 1 значение
function foo2() return "a", "b" end -- возвращает 2 значения
```





***

Полезное: как определить аргумент по умолчанию:

```lua
function incCount(n)
    n = n or 1
    count = count + n
end
```









***



Функции в Lua являются значениями первого класса с соответствующей лексической областью видимости. Что для функций означает быть «значениями первого класса»? Это значит, что в Lua функция — это значение, обладающее теми же правами, что и традиционные значения вроде чисел и строк. Мы можем хранить функции в переменных (локальных и глобальных) и таблицах, мы можем передавать функции как аргументы и возвращать их из других функций.



В обоих случаях заключение списка аргументов в круглые скобки обозначает вызов; если у вызова функции нет аргументов, то мы все равно должны написать пустой список () для обозначения вызова. Существует особое исключение из этого правила: если у функции всего один аргумент и этот аргумент либо строковый литерал, либо конструктор таблицы, то круглые скобки необязательны:

```lua
print "Hello World" <--> print("Hello World")
dofile 'a.lua' <--> dofile ('a.lua')
print [[a multi-line <--> print([[a multi-line
message]] <--> message]])
f{x=10, y=20} <--> f({x=10, y=20})
type{} <--> type({})
```

Lua также предлагает специальный синтаксис для объектноориентированных вызовов — операцию двоеточия. Выражение вроде о:foo(x) — это всего лишь другой способ написать o.foo(o,x), то есть вызвать o.foo, добавляя o в качестве первого дополнительного аргумента. В главе 16 мы обсудим подобные вызовы (и объектноориентированное программирование) более подробно.

Программа Lua может использовать функции, написанные как на Lua, так и на С (или любом другом языке, который используется основным приложением). Например, все функции из стандартной библиотеки Lua написаны на С. Тем не менее, при вызове нет никакой разницы между функциями, определенными в Lua, и функциями, определенными в С.

определение функции следует традиционному синтаксису, например, как показано ниже:

```lua
-- складывает элементы последовательности 'a'
function add (a)
    local sum = 0
    for i = 1, #a do
        sum = sum + a[i]
    end
    return sum
end
```

В этом синтаксисе определение функции содержит имя (в примере это add), список параметров и тело, которое является списком операторов.

Параметры работают в точности как локальные переменные, проинициализированные значениями аргументов, которые были переданы вызову функции. Вы можете вызвать функцию с числом аргументов, отличным от ее числа параметров. Lua приведет число аргументов к числу параметров так же, как и при множественном присваивании: лишние аргументы отбрасываются, лишние параметры получают nil. Например, рассмотрим следующую функцию:

```lua
function f (a, b) print(a, b) end

f(3) --> 3 nil
f(3, 4) --> 3 4
f(3, 4, 5) --> 3 4 (5 отбрасывается)
```

{% hint style="info" %}
Такое поведение удобно для задания параметров по умолчанию:

```lua
function incCount (n)
    n = n or 1        -- если не будет указан аргумент, то n будет равен 1
    count = count + n
end
```
{% endhint %}









## Определение функций

Типичное определение функции выглядит следующим образом:

```lua
function f(x,y) 
   return x*y -- тело функции
end
```

Как видно из этого примера, определение функции состоит из следующих элементов:

* ключевого слова function
* имени (f в данном примере)
* заключённого в круглые скобки списка аргументов функции (возможно, пустого)
* тела функции, размещённого между закрывающей скобкой и ключевым словом end

Приведённое выше определение функции является просто более удобным способом записи (синтаксический сахар) следующего выражения:

```lua
f = function (x, y)
   return x*y -- тело функции
end
```

Таким образом, определение функции фактически выполняет два действия:

* Создаёт объект типа «функция» (это делает выражение _function (x,y) ... end_).
* Помещает ссылку на созданную функцию в переменную или поле таблицы (в нашем примере — в переменную f).



{% hint style="danger" %}
Имя f принадлежит переменной, в которую помещена ссылка на функцию, но не самой функции. Любые функции в Lua анонимны, то есть не имеют имён. Когда говорят об имени функции, например, «функция f», на самом деле подразумевают переменную f, содержащую ссылку на эту функцию. У переменных, содержащих ссылки на функции, нет жёсткой привязки к самим функциям; работа с такими переменными осуществляется точно так же, как и с любыми другими переменными.

```lua
function f(x,y) return x*y end -- создаем функцию, переменная f содержит ссылку на эту функцию
print(f(2,3))--> 6
s = f -- переменная s ссылается на ту же функцию, что и f
print(s(2,3))--> 6
t = {} 
t.sqr = f -- поле sqr таблицы t ссылается на ту же функцию, что и f
print((t.sqr(2,3))--> 6
f = print -- f теперь "превратилась" в функцию MsgBox
f("Привет, мир!") --> "Привет, мир!"
```
{% endhint %}

Несмотря на то, что обычно ссылка на созданную функцию присваивается переменной, такое присваивание не является обязательным. В приведённом ниже примере создаётся безымянная функция, которая сразу передаётся в качестве параметра в функцию table.sort:

```lua
table.sort(t, function (a, b) return (a > b) end)
```

## Вызов функции в Lua

Вызов функции состоит из имени переменной, содержащей ссылку на функцию, и заключённого в круглые скобки списка аргументов (возможно, пустого).

```lua
a = f(2,3) -- вызов функции f с двумя аргументами: 2 и 3
           -- возвращаемое функцией значение помещается в переменную a
```

Если функции передаётся только один аргумент, и этот аргумент является строковой константой или конструктором таблицы, круглые скобки при вызове функции можно не использовать.

```lua
require "myscript" -- то же самое, что и require ("myscript")
MsgBox [[Это многострочное значение]] -- то же самое, что и MsgBox([[Это многострочное значение]])
render {x=1, y=2} -- то же самое, что и render({x=1, y=2})
```

Ссылка на функцию может быть полем таблицы. В этом случае вызов функции будет выглядеть так:

```lua
t.f() -- вызов функции, на которую ссылается поле f таблицы t
```

В Lua имеется возможность вызова функции в объектно-ориентированном стиле:

```lua
t:f() --эквивалентно t.f(t)
```

Таким образом, конструкция t:f() вызывает функцию, на которую ссылается поле f таблицы t, и эта же таблица передаётся в функцию в качестве неявного первого аргумента. В качестве аргументов функция может принимать несколько значений. Если при вызове функции последние значения не заданы, им присваивается nil. Если значений больше, чем аргументов, «лишние» значения отбрасываются. Аргументы функции являются локальными переменными внутри функции.

```lua
function f(x, y) -- определение функции
   print("x="..tostring(x).."; ".."y="..tostring(y))
end
f() -- вызов функции. x, y равны nil
f(1) -- вызов функции. x = 1, y равен nil
f(1, 2) -- вызов функции. x = 1, y = 2
f(1, 2, 3) -- вызов функции. x = 1, y = 2, 3 - лишний параметр
```

## Функции с переменным числом аргументов

Функция может принимать переменное число параметров. Для этого список аргументов в определении функции должен заканчиваться многоточием (...).

```lua
function f(x, y, ...)
end
```

## Возврат значений из функции

Функции могут возвращать одно или несколько значений, а также не возвращать значений вообще.

```lua
function f0() -- функция f0 не возвращает значений
   print("Вызвана функция f0")
end
function f1()
   print("Вызвана функция f1")
   return 1 -- функция f1 возвращает одно значение
end
function f3()
   print("Вызвана функция f3")
   return 1, 2, 3 -- функция f3 возвращает три значения
end
f0() -- вызов функции f0
a = f1() -- вызов функции f1. a = 1
a, b, c = f3() -- вызов функции f3. a = 1, b = 2, c = 3
```

Если количество возвращаемых функцией значений превышает число переменных, которым эти значения должны быть присвоены, «лишние» значения отбрасываются. Если возвращаемых значений меньше, чем переменных, отсутствующие значения заменяются nil.

```lua
a = f3() -- a = 1, значения 2 и 3 отброшены
a, b, c = f3() -- a = 1, b = 2, значение 3 отброшено
a, b, c = f0() -- a = nil, b = nil, c = nil
a, b, c = f1() -- a = 1, b = nil, c = nil
```

Вне зависимости от того, возвращает функция значения или нет, её можно вызвать как оператор. Все возвращаемые функцией значения в этом случае будут отброшены:

```lua
f3() -- значения, возвращенные функцией f3, отброшены
```

Возникают ситуации, когда функция возвращает несколько значений, а переменной требуется присвоить только одно из них. Например, функция возвращает три значения, а для работы нужно только последнее:

```lua
local a, b, c = f3()
```

Как не задавать лишних имён переменных? Здесь общепринятым способом является использование переменной с именем «\_» (символом подчёркивания). Это упрощает внешний вид выражения и указывает на реально используемые переменные.

```lua
local _, _, c = f3() -- нам нужно только третье возвращаемое значение
```

Такой же подход часто используется в работе с итераторами:

<pre class="language-lua"><code class="lang-lua">for _, value in pairs() do 
<strong>    print(value) -- нам нужно только очередное значение, ключ будет присвоен переменной _
</strong>end
</code></pre>

### Возврат значений при множественном присваивании

При использовании множественного присваивания все возвращаемые функцией значения учитываются только в том случае, если вызов функции является последним (или единственным) выражением в списке выражений справа от оператора присваивания. В противном случае в присваивании участвует только одно (первое) возвращённое функцией значение.

```lua
a, b, c, d = 5, f3() -- a = 5, b = 1, c = 2, d = 3
a, b, c, d = f3(), 5 -- a = 1, b = 5, c = nil, d = nil
```

Аналогичным образом учитываются результаты вызова функции, включённого в конструктор таблицы, список аргументов другой функции и в список результатов, возвращаемых оператором return.

```lua
t = {5, f3()} -- t = {5, 1, 2, 3}
t = {f3(), 5} -- t = {1, 5}
func (5, f3()) -- вызов функции func с аргументами 5, 1, 2, 3
func (f3(), 5) -- вызов функции func с аргументами 1, 5
return 5, f3() -- возврат значений 5, 1, 2, 3
return f3(), 5 -- возврат значений 1, 5
```

### Возврат функций из функций

Функции можно возвращать из функций. Например:

```lua
function outer()
   function inner()
      return 1 
   end
   return inner
end
local i = outer() -- значение переменной i равно функции inner
local a = i() -- вызываем функцию i, значение переменной a равно 1
```
