---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Функции

Функция в Lua является основным механизмом абстракции операторов и выражений. Проще говоря, функция - это специальная конструкция в языке которая позволяет объединить кусок кода, который выполняет определенную задачу. Это позволяет позднее использовать этот код произвольное количество раз (что позволяет избежать дублирования кода) и разделить код на достаточно простые и легко управляемые части.

## 1. Как использовать функции

Классический вызов функции состоит из указания ее идентификатора и круглых скобок (внутри которых можно указать аргументы функции). К примеру, попробуем вызвать встроенную функцию print с различными вариантами аргументов:

```lua
print()
print("DUCK")
print("DOG", "DUCK")
```

Если в функцию передается всего один аргумент, то можно использовать сокращенный вызов функции, не указывая круглые скобки:

```lua
print "DUCK"
```

{% hint style="info" %}
Лучше стараться использовать классический синтаксис вызова функции, т.к. это позволяет быстрее определить что перед нами вызов функции.
{% endhint %}

***

Функции можно поделить на 2 типа:&#x20;

1. Функции которые выполняют определенную задачу и не возвращают значение (часто называемые процедурой или подпрограммой в других языках)&#x20;
2. Функции которые вычисляют и возвращают значение

В первом случае мы используем вызов функции как оператор:

```lua
print("DUCK")
```

Во втором случае мы можем использовать ее как выражение:

```lua
a = math.sin(3) + math.cos(10)
print(os.date())
```

## 2. Определение функции

## Определение функций

Типичное определение функции выглядит следующим образом:

```lua
function f(x,y) 
   return x*y -- тело функции
end
```

Как видно из этого примера, определение функции состоит из следующих элементов:

* ключевого слова function
* имени (f в данном примере)
* заключённого в круглые скобки списка аргументов функции (возможно, пустого)
* тела функции, размещённого между закрывающей скобкой и ключевым словом end

Приведённое выше определение функции является просто более удобным способом записи (синтаксический сахар) следующего выражения:

```lua
f = function (x, y)
   return x*y -- тело функции
end
```

Таким образом, определение функции фактически выполняет два действия:

* Создаёт объект типа «функция» (это делает выражение _function (x,y) ... end_).
* Помещает ссылку на созданную функцию в переменную или поле таблицы (в нашем примере — в переменную f).







***

Традиционный синтаксис функции в Lua следующий:

```lua
function add(a)
    local sum = 0
    for i = 1, #a do
        sum = sum + a[i]
    end
    return sum
end
```

В этом синтаксисе определение функции содержит имя (add), список параметров и тело, которое является списком операторов.

***

В Lua функция - это значение, обладающее теми же правами, что и традиционные значения вроде чисел и строк. Мы можем хранить функции в переменных (локальных и глобальных) и таблицах, мы можем передавать функции как аргументы и возвращать их из других функций.

Функции в Lua, как и другие значения, являются анонимными (у них нет имен). Когда мы говорим об имени функции (например print), на самом деле мы имеем ввиду переменную с именем print, которая хранит данную функцию.

Как и с любой другой переменной, мы можем манипулировать этими переменными множеством способов:

```lua
a = {p = print}
a.p("DUCK")      --> DUCK
print = math.sin -- 'print' теперь ссылается на функцию sin
a.p(print(1))    --> 0.841470
sin = a.p        -- 'sin' теперь ссылается на функцию print
sin(10, 20)      --> 10 20
```

***

Традиционный синтаксис определения Lua функции  - это так называемый "синтаксический сахар".

Например, функция, определенная следующим образом

```lua
function sum(a, b) return a + b end
```

это всего лишь более красивый способ написать следующий код:

```lua
sum = function(a, b) return a + b end
```

Таким образом, определение функции - это по сути оператор, который создает значение типа "function" и присваивает его переменной.

## 3. Параметры функции

Параметры работают в точности как другие локальные переменные внутри функции. Они создаются при входе в функцию, инициализируются значениями переданных аргументов и уничтожаются при выходе из функции.

Вы можете вызвать функцию с числом аргументов, отличным от ее числа параметров. Lua приведет число аргументов к числу параметров: лишние аргументы отбрасываются, а если аргументов было меньше чем параметров, то лишние параметры получат nil.

Пример:

```lua
function f(a, b)
    print(a, b)
end

f(3)        --> 3 nil
f(3, 4)     --> 3 4
f(3, 4, 5)  --> 3 4
```

### 3.1. Переменное количество аргументов

В Lua можно создать функцию, которая будет принимать и корректно обрабатывать переменное количество аргументов. Для этого нужно написать (...) в списке параметров функции:

```lua
function add (...)
    local s = 0
    for i, v in ipairs({...}) do
        s = s + v
    end
    return s
end
print(add(3, 4, 10, 25, 12)) --> 54
print(add(2, 2)) --> 4
```

Получить доступ к переданным аргументам можно с помощью выражения (...). Оно ведет себя как функция с возвратом нескольких значений (подробнее об этом ниже).

```lua
function test(...)
    print(...)
    
    local a, b = ...
    
    test2(1, 2, ...)
    
    for i, v in ipairs({...}) do
        print(i, v)
    end
    
    return ...
end

function test2(a, b, ...)
    print(a, b, ...)
end
```

### 3.2. Именованные аргументы

Механизм передачи параметров в Lua является позиционным: при вызове функции аргументы сопоставляются с параметрами соответственно их позициям. Первый аргумент дает значение первому параметру и т. д.

Но иногда удобно задавать аргументы по имени. В таком случае можно передавать в функцию таблицу как единственный аргумент. И в таблице указать пары ключ-значение. Пример:

```lua
w = Window({x = 0, y = 0, width = 200, height = 300})

function Window(args)
    local x = args.x or 0
    local y = args.y or 0
    local width = args.width or 500
    local height = args.height or 400
    -- <DO SOME STUFF FOR CREATE WINDOW FORM>
    return windowForm
end
```

## 4. Возврат значений из функции

В Lua функции могут возвращать любое количество значений (или не возвращать вовсе). В случае когда функция возвращает более одного значения, сохранить результат функции позволяет множественное присваивание.

Примеры:

```lua
function f()
    return "A"    -- 
end

function g()
    return "B", "C", "D"
end

function h()
    print("DUCK")
end

a = f()
b, c, d = g()
h()                  --> DUCK
print(a, b, c, d)    --> A B C D
```

!! Можно использовать return чтобы раньше закончить выполнение функции. Также можно return не указывать.

!! Lua всегда приводит количество результатов функции к обстоятельствам ее вызова. Когда мы вызываем функцию как оператор, Lua отбрасывает все результаты функции. Когда мы используем вызов как выражение, Lua оставляет только первый результат. Мы получаем все результаты лишь тогда, когда вызов является последним (или единственным) выражением в списке выражений. В Lua эти списки встречаются в четырех конструкциях: множественные присваивания, аргументы в вызовах функций, конструкторы таблиц и операторы return. Для иллюстрации всех этих случаев допустим, что у нас есть такие определения для наших последующих примеров:

```lua
function foo0() end -- возвращает 0 значений
function foo1() return "a" end -- возвращает 1 значение
function foo2() return "a", "b" end -- возвращает 2 значения
```

## 5. Анонимные функции

В приведённом ниже примере создаётся безымянная функция, которая сразу передаётся в качестве параметра в функцию table.sort:

```lua
table.sort(t, function (a, b) return (a > b) end)
```

***

Полезное: как определить аргумент по умолчанию:

```lua
function incCount(n)
    n = n or 1
    count = count + n
end
```

{% hint style="info" %}
Когда программа вызывает функцию, управление программой передается вызываемой функции. Вызываемая функция выполняет определенную задачу, и когда выполняется оператор return или когда достигается конец ее функции, она возвращает управление программой обратно в основную программу.
{% endhint %}

!! Так как функции в Lua можно хранить как обычные значения, мы можем хранить их в таблицах. Функции которых хранятся как полях в таблицах, можно вызвать следующим образом:

```lua
t = {}
t.p = print
t.p("DUCK")    --> DUCK
```

Также Lua предлагает специальный синтаксис для объектно-ориентированных вызовов - операцию двоеточия:

```lua
o = {}
o.count = 0
o.incCount = function(self, number) self.count = self.count + 1 end

print(o.count)
o:incCount(10)
print(o.count)
```

Этот способ является всего лишь другим способом написать следующее:

```lua
o.incCount(o, 10)
```

Подробнее про ООП в Lua читайте в статье про ООП

\---

Ссылка на функцию может быть полем таблицы. В этом случае вызов функции будет выглядеть так:

```lua
t.f() -- вызов функции, на которую ссылается поле f таблицы t
```

В Lua имеется возможность вызова функции в объектно-ориентированном стиле:

```lua
t:f() --эквивалентно t.f(t)
```

Таким образом, конструкция t:f() вызывает функцию, на которую ссылается поле f таблицы t, и эта же таблица передаётся в функцию в качестве неявного первого аргумента.





{% hint style="info" %}
Программа Lua может использовать функции, написанные как на Lua, так и на С (или любом другом языке, который используется основным приложением). Например, все функции из стандартной библиотеки Lua написаны на С. Тем не менее, при вызове нет никакой разницы между функциями, определенными в Lua, и функциями, определенными в С.
{% endhint %}

***















##





## Вызов функции в Lua

Вызов функции состоит из имени переменной, содержащей ссылку на функцию, и заключённого в круглые скобки списка аргументов (возможно, пустого).

```lua
a = f(2,3) -- вызов функции f с двумя аргументами: 2 и 3
           -- возвращаемое функцией значение помещается в переменную a
```

Если функции передаётся только один аргумент, и этот аргумент является строковой константой или конструктором таблицы, круглые скобки при вызове функции можно не использовать.

```lua
require "myscript" -- то же самое, что и require ("myscript")
MsgBox [[Это многострочное значение]] -- то же самое, что и MsgBox([[Это многострочное значение]])
render {x=1, y=2} -- то же самое, что и render({x=1, y=2})
```

&#x20;В качестве аргументов функция может принимать несколько значений. Если при вызове функции последние значения не заданы, им присваивается nil. Если значений больше, чем аргументов, «лишние» значения отбрасываются. Аргументы функции являются локальными переменными внутри функции.

```lua
function f(x, y) -- определение функции
   print("x="..tostring(x).."; ".."y="..tostring(y))
end
f() -- вызов функции. x, y равны nil
f(1) -- вызов функции. x = 1, y равен nil
f(1, 2) -- вызов функции. x = 1, y = 2
f(1, 2, 3) -- вызов функции. x = 1, y = 2, 3 - лишний параметр
```

## Функции с переменным числом аргументов

Функция может принимать переменное число параметров. Для этого список аргументов в определении функции должен заканчиваться многоточием (...).

```lua
function f(x, y, ...)
end
```

## Возврат значений из функции

Функции могут возвращать одно или несколько значений, а также не возвращать значений вообще.

```lua
function f0() -- функция f0 не возвращает значений
   print("Вызвана функция f0")
end
function f1()
   print("Вызвана функция f1")
   return 1 -- функция f1 возвращает одно значение
end
function f3()
   print("Вызвана функция f3")
   return 1, 2, 3 -- функция f3 возвращает три значения
end
f0() -- вызов функции f0
a = f1() -- вызов функции f1. a = 1
a, b, c = f3() -- вызов функции f3. a = 1, b = 2, c = 3
```

Если количество возвращаемых функцией значений превышает число переменных, которым эти значения должны быть присвоены, «лишние» значения отбрасываются. Если возвращаемых значений меньше, чем переменных, отсутствующие значения заменяются nil.

```lua
a = f3() -- a = 1, значения 2 и 3 отброшены
a, b, c = f3() -- a = 1, b = 2, значение 3 отброшено
a, b, c = f0() -- a = nil, b = nil, c = nil
a, b, c = f1() -- a = 1, b = nil, c = nil
```

Вне зависимости от того, возвращает функция значения или нет, её можно вызвать как оператор. Все возвращаемые функцией значения в этом случае будут отброшены:

```lua
f3() -- значения, возвращенные функцией f3, отброшены
```

Возникают ситуации, когда функция возвращает несколько значений, а переменной требуется присвоить только одно из них. Например, функция возвращает три значения, а для работы нужно только последнее:

```lua
local a, b, c = f3()
```

Как не задавать лишних имён переменных? Здесь общепринятым способом является использование переменной с именем «\_» (символом подчёркивания). Это упрощает внешний вид выражения и указывает на реально используемые переменные.

```lua
local _, _, c = f3() -- нам нужно только третье возвращаемое значение
```

Такой же подход часто используется в работе с итераторами:

<pre class="language-lua"><code class="lang-lua">for _, value in pairs() do 
<strong>    print(value) -- нам нужно только очередное значение, ключ будет присвоен переменной _
</strong>end
</code></pre>

### Возврат значений при множественном присваивании

При использовании множественного присваивания все возвращаемые функцией значения учитываются только в том случае, если вызов функции является последним (или единственным) выражением в списке выражений справа от оператора присваивания. В противном случае в присваивании участвует только одно (первое) возвращённое функцией значение.

```lua
a, b, c, d = 5, f3() -- a = 5, b = 1, c = 2, d = 3
a, b, c, d = f3(), 5 -- a = 1, b = 5, c = nil, d = nil
```

Аналогичным образом учитываются результаты вызова функции, включённого в конструктор таблицы, список аргументов другой функции и в список результатов, возвращаемых оператором return.

```lua
t = {5, f3()} -- t = {5, 1, 2, 3}
t = {f3(), 5} -- t = {1, 5}
func (5, f3()) -- вызов функции func с аргументами 5, 1, 2, 3
func (f3(), 5) -- вызов функции func с аргументами 1, 5
return 5, f3() -- возврат значений 5, 1, 2, 3
return f3(), 5 -- возврат значений 1, 5
```

### Возврат функций из функций

Функции можно возвращать из функций. Например:

```lua
function outer()
   function inner()
      return 1 
   end
   return inner
end
local i = outer() -- значение переменной i равно функции inner
local a = i() -- вызываем функцию i, значение переменной a равно 1
```
