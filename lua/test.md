---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# TEST

### Переменные

! В луа не нужен разделитель между идущими подряд операторами. (Но вы можете их использовать. Например удобно использовать их для разделения двух или более операторов записанных в одной строке)

```lua
a = 1
b = a*2

c = 2 + 2; d = c / 2
```

* Идентификаторы (имена) в Lua могут быть любой последовательностью из букв (A-Z и a-z), цифр и символов подчеркивания, не начинающейся с цифры. Например:

```
i    j    i10    _ij    aSomewhatLongName    _INPUT
```

! Лучше избегать индентификаторов, начинающихся с символа подчеркивания, за которым следует одна или несколько заглавных букв (например \_VERSION). Они зарезервированы в Луа для особых целей.

Совет: для переменных, значения которых не особо важно, удобно использовать \_ (одиночный символ подчеркивания)

Зарезервированные слова (их нельзя использовать в качестве идентификаторов):

```
and      break    do      else   elseif
end      false    goto    for    function
if       in       local   nil    not
or       repeat   return  then   true
until    while
```

Lua учитывает регистр букв: and - зарезервированное слово, но And и AND - это два отличных от него и друг от друга идентификатора.

Глобальным переменным не нужны объявления. Их можно сразу использовать. Обращение к неинициализированной переменной не является ошибкой - вы всего лишь получите значение nil в качестве результата:

```lua
print(b)    --> nil
b = 10
print(b)    --> 10
```

Также переменной вновь присвоить значение nil. В таком случае Луа поведет себя так, как если бы эта переменная никогда не использовалась. (После данного присваивания Луа может со временем высвободить память, выделенную под эту переменную.

```
b = nil
print(b)    --> nil
```

### Типы и значения

Луа - язык с динамической типизацией. В нем нет определений типов - каждое значение содержит в себе свой собственный тип (???)

_В Луа существует 8 базовых типов:_

#### Отсутствие значения (nil)

Основная задача типа состоит в том, чтобы отличаться от всех остальных значений. Луа использует nil как нечто, не являющееся значением, чтобы изобразить отсутствие значения.&#x20;

#### Логические значение (boolean)

Тип обладает двумя значениями - <mark style="color:red;">true</mark> и <mark style="color:red;">false</mark>, которые представляют традиционные логические (булевы) значения.

В луа логическое условие может быть представлено любым значением. Проверки условий считают nil и false ложными, а все прочие значения истинными. (к примеру, ноль и пустая строка будут считаться истинными значениями)

#### Числа (number)

Тип number представляет вещественные числа, т.е. числа двойной точности с плавующей точкой (тип double). В луа нет целочисленного типа.

! Проблем с операциями на целыми числами нет (вплоть до 2^53). Никаких ошибок округления с целыми числами в данном диапазоне не происходит. Но вот с дробными числами нужно знать следующий нюанс: если число не имеет точного представления в двоичном виде (например 12.7) то число будет округлено. И выражение "12.7 - 20 + 7.3" не будет равно нулю.

```
print(12.7 - 20 + 7.3)    --> -8.8817841970013e-16
```

В Луа можно записывать числа в десятеричной и шестнадцатеричной системе:

```
4    0.4    4.57e-3    0.3e12    5E+20

0xff (255)    0x1A3 (419)    0x0.2 (0.125)    0x1p-1 (0.5)
```

#### Строки (string)

Тип string в Луа имеет обычный смысл: последовательность символов.

В виде строк можно хранить любые бинарные данные.

Строки в Луа являются неизменяемыми значениями. При изменение символа внутри строки создается новая строка с необходимыми изменениями.

Строки в Луа подвержены автоматическому управлению памятью, как и любые другие объекты в Луа (таблицы, функции и т.д.). Это значит, что вам не нужно беспокоиться о выделении и освобождении строк - этим за вас займется Луа. Строка можно состоять из любого количества символов.

Чтобы получить длину строки - используйте префиксную операцию "#" (операция длины)

```
a = "DUCK"
print(#a)                --> 4
print(#"good\0bye")      --> 8
```

Определить строку можно с помощью одинарных или двойных кавычек. Единственное отличие - внутри одного вида кавычек вы можете использовать другой, не применяя экранирование символов.&#x20;

Пример экранированного символа переноса строки ("\n"):

```
s = "First line\nSecond line"
print(s)    --> First line
                Second line
```

! Большинство программистов всегда использует кавычки одного вида для одних и тех же видов строк, где "виды" строк зависят от программы.

В луа можно задать длинные строки следующим образом:

```
page = [[
<html>
    <head>
        <title>An HTML Page</title>
    </head>
</html>
]]

```

\-- В случае если вам нужно записать в строку данные что содержат "]]" (например a = b\[c\[i]]), тогда можно использовать скобки со произвольным количеством знаков равенства между ними. Также работает и многострочными комментариями! (удобно в случае когда нужно закомментировать большой кусок кода в котором уже есть многострочные комментарии)

```
-- СТРОКА
someString = [===[
a = b[c[i]]
print(a)
]===]

-- КОММЕНТАРИЙ
--[=[
print(a)
print(b)
--]=]
```

**Приведение типов**

Луа обеспечивает автоматическое преобразование между числами и строками во время выполнения программ. Строка преобразуется в число в случае когда к ней применяется числовая операция или если она используется в качестве параметра в функции, где ожидается число. Число преобразуется в строку там, где ожидается строка.

{% hint style="danger" %}
Лучше не рассчитывать на автоматическое приведение данных типов. Используйте явное приведение типов с помощью функций tonumber(...) и tostring(...)
{% endhint %}

#### Таблицы (table)

Тип table представляет ассоциативные массивы. Ассоциативный массив - это массив, который может быть индексирован не только числами, но и строками и любым другим значением языка, кроме nil.

Таблицы являются главным (и единственным) механизмом структурирования данных в Луа, притом очень эффективным. Мы используем для представления обычных массивов, множеств, записей и других структур данных простым, однородным и эффективным способом. Также луа использует таблицы для представления пакетов и объектов. Когда мы пишем io.read, мы думаем о "функции read из модуля io". Для Луа это выражение означает "индексировать таблицу io, используя строку read в качестве ключа".

Таблицы в луа являются ни значениями, ни переменными - они _объекты._ Вы можете рассматривать таблицу как динамически выделяемый объект. Ваша программа работает только с ссылками (указателями) на них. Луа никогда не прибегает к скрытому копированию или созданию новых таблиц.&#x20;

Таблицы создаются с помощью выражения-конструктора:

```lua
a = {}    -- создает таблицу и сохраняет ссылку на нее в 'a'
k = "x"
a[k] = 10    -- новая запись с ключом "x" и значением 10
a[20] = "great"    -- новая запись с ключом 20 и значением "great"
print(a["x"])    --> 10
k = 20
print(a[k])    --> great
a["x"] = a["x"] + 1     -- инкрементирует запись "x"
print(a["x"])    --> 11
```

Таблица всегда анонимна. Не существует постоянной связи между переменной, которая хранит таблицу и самой таблицей:

```lua
a = {}
a["x"] = 10
b = a            -- 'b' ссылается на ту же таблицу, что и 'a'
print(b["x"])    --> 10
b["x"] = 20
print(a["x"])    --> 20
a = nil          -- лишь 'b' по-прежнему ссылается на ту таблицу
b = nil          -- ссылок на таблицу не осталось
```

Когда в программе больше не остается ссылок на таблицу, сборщик мусора луа со временем удалит эту таблицу, чтобы повторно использовать ее память.

Каждая таблица может хранить значения с разными типами индексов и растет по мере добавления новых записей.

Поля таблицы возвращают nil, когда не инициализированы. Вы можете присвоить nil полю таблицы чтобы удалить его.

Вы можете использовать имя поля таблицы как индекс и обращаться к ним следующим образом:

```lua
a = {}
a["x"] = 10
print(a.x)    -- то же, что и print(a["x"])
```

{% hint style="warning" %}
Типичная ошибка новичков - спутать a.x с a\[x]. Первая форма соответствует a\["x"], а вторая означает, что таблица индексирована при помощи значения переменной x.

```lua
a = {}
x = "y"
a[x] = 10
print(a[x])    --> 10
print(a.x)     --> nil
print(a.y)     --> 10
```
{% endhint %}

Чтобы представить традиционный массив или список, просто используйте таблицу с целочисленными ключами. Нет ни способа, ни необходимости объявлять размер. Вы всего лишь инициализируете те элементы, которые вам нужны:

```lua
-- считывает 10 строк, сохраняя их в таблице
a = {}
for i = 1, 10 do
    a[i] = io.read()
end
```

{% hint style="info" %}
Поскольку вы можете индексировать таблицу любым значением, вы можете начинать индексы массива с любого числа, которое вам нравится. Однако в луа принято начинать массивы с единицы (а не с нуля). Некоторые средства луа придерживаются этого соглашения и для того чтобы с ними корректно работать нужно придерживаться этого правила.
{% endhint %}

Когда вы работаете со списком, обычно вам нужно знать его длину. Она может быть константой или хранится где-то еще. Часто мы храним длину списка в нечисловом поле таблицы (например поле "n").

В луа существует операция длины "#". Она работает также для таблиц, которые хранят последовательности (последовательность в луа - это таблица с целочисленными ключами начиная с 1. В последовательности не должно быть дыр, т.е. элементов с значением nil). Операция длины считает элементы начиная с 1 до первого значения, которое равно nil.

```lua
a = {}
a[1] = "A"
a[2] = true
a[3] = 354

print(#a)    --> 3

b = {}
b[1] = 7
b[2] = "str"
b[1000] = true

print(#b)    --> 2
```

#### Функции (function)

Функции (тип function) являются в Lua значениями первого класса: программы могут хранить функции в переменных, передавать функции как аргументы для других функций и возвращать  функции как результаты.

Луа может вызывать функции написанные на Луа и функции написанные других языках (например функции из луа модуля, который написан на C).&#x20;

#### Пользовательские данные (userdata)

Тип userdata позволяет запоминать произвольные данные C в переменных Lua. У него нет предопределенных операций в Луа, за исключением присваивания и проверки на равенство.&#x20;

Этот тип используется для представления новых типов, созданных прикладной программой или библиотекой, написанной на C.

#### Потоки (thread)























### Комментарии

```lua
a = 0 -- Однострочный комментарий

--[[
Пример многострочного комментария
a = 10
print(a)
--]]
```

{% hint style="info" %}
Многострочные комментарии удобны для комментирования кусков кода. При необходимости потом легко можно восстановить работоспособность кода просто добавив "-" (дефис) пере началом комментария:

```lua
---[[
print(10)
--]]
```
{% endhint %}

