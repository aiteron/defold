---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Итераторы и замыкания

## Замыкания

Замыкание — это функция, которая обращается к одной или нескольким локальным переменным из охватывающего ее окружения.

Рассмотрим пример:

```lua
function newCounter()
    local i = 0
    return function()
        i = i+1
        return i
    end
end

local c1 = newCounter()
print(c1())    --> 1
print(c1())    --> 2
local c2 = newCounter()
print(c2())    --> 1
print(c1())    --> 3
print(c2())    --> 2
```

В этом коде анонимная функция ссылается на нелокальную переменную i для хранения своего счетчика. Однако, к тому времени, как мы вызовем анонимную функцию, переменная i уже выйдет из своей области видимости, поскольку функция, которая создала эту переменную (newCounter), уже будет возвращена. Тем не менее, Lua правильно обрабатывает эту ситуацию, используя концепцию замыкания (closure). Проще говоря, замыкание — это функция вместе со всем, что ей нужно для правильного доступа к нелокальным переменным.

При новом вызове newCounter, функция создаст новую локальную переменную i, поэтому мы получим новое замыкание, действующее поверх новой переменной.

***

С помощью замыканий можно реализовывать много полезного функционала. Вот некоторые способы использовать замыкания:

**Замыкания можно использовать как аргументы для других функций:**

```lua
names = {"Peter", "Paul", "Mary"}
grades = {Mary = 10, Paul = 7, Peter = 8}
table.sort(names, function (n1, n2)
    return grades[n1] > grades[n2] -- сравнивает оценки
end)
```

**Замыкания позволяют легко переопределять функции:**

```lua
local oldSin = math.sin
math.sin = function(x)
    return oldSin(x*math.pi/180)
end

-- Есть еще более безопасный вариант:
do
    local oldSin = math.sin
    local k = math.pi/180
    math.sin = function(x)
        return oldSin(x*k)
    end
end
```

Переопределение функций позволяет создавать безопасное окружение (песочницу). Это позволяет безопасно выполнять ненадежный код (например код полученный из интернета или из модификаций для игры). После переопределения функции для программы нет способа вызвать оригинальную функцию.

Также замыкания можно использовать как функции обратного вызова (устанавливать объектам функции, которые используют внутри себя переменные из внешнего контекста).

## Итераторы

Итератор (iterator) — это любая конструкция, которая позволяет вам перебирать элементы коллекции. В Lua мы обычно представляем итераторы при помощи функций: каждый раз, когда мы вызываем функцию, она возвращает «следующий» элемент из коллекции.

Любой итератор должен где-то хранить свое состояние между последовательными вызовами, чтобы знать, где он находится и как себя вести с этого места. Замыкания предоставляют великолепный механизм для этой задачи. Внешние переменные замыкания хранят свои значения между последовательными вызовами, позволяя тем самым замыканию помнить, где оно находится при переборе элементов. Разумеется, для создания нового замыкания мы также должны создать его нелокальные переменные. Поэтому конструкция замыкания обычно включает в себя две функции: само замыкание и фабрику — функцию, которая создает замыкание вместе с окружающими ее переменными.

Рассмотрим пример - итератор для списка, который возвращает значение каждого элемента:

```lua
function values(t)
    local i = 0
    return function() i = i + 1; return t[i] end
end
```

В этом примере values - это фабрика. Каждый раз, когда мы вызываем эту фабрику, она создает новое замыкание (сам итератор). Это замыкание хранит свое состояние в своих внешних переменных t и i.Каждый раз, когда мы вызываем этот итератор, он возвращает следующее значение из списка t. После последнего элемента итератор вернет nil, что означает конец итерации.

Чаще всего итераторы используются в общем for:

```lua
t = {10, 20, 30}
for element in values(t) do
    print(element)
end
```

for хранит внутри итерирующую функцию (полученную от фабрики), вызывает итератор для каждой новой итерации цикла и останавливает цикл, когда итератор возвращает nil.

### Семантика общего for

Единственным недостатком ранее рассмотренных итераторов является то, что нам необходимо создавать новое замыкание для инициализации каждого нового цикла. Однако мы можем обойтись без замыкания используя общий for для хранения состояния итерации.

На самом деле общий for хранит три значения: итерирующую функцию, инвариантное (неизменяющееся) состояние и управляющую переменную.

Синтаксис общего for следующий:

```
for <список_переменных> in <список_выражений> do
    <тело>
end
```

Список переменных - это список из одного или нескольких имен переменных, разделенных запятыми. Список выражений - это список из одного или нескольких выражений, также разделенных запятыми. Часто список выражений состоит из единственного элемента - вызова фабрики итераторов.

```lua
for k, v in pairs(t) do
    print(k, v)
end

for line in io.lines() do
    io.write(line, "\n")
end
```

Первая переменная из списка переменных называется управляющей переменной. В течении всего цикла ее значение никогда не равно nil, поскольку когда она становится равной nil, цикл завершается.

Первое, что делает цикл for - вычисляет выражение после in. Эти выражения должны дать три значения, которые хранит for: итерирующая функция, инвариантное состояние и начальное значение управляющей переменной. При использовании простых итераторов, фабрика возвращает только итерирующую функцию, а остальные значения будут равны nil.

После этого шага for вызывает итерирующую функцию с двумя аргументами: инвариантным состоянием и управляющей функцией.

**Рассмотрим создание итератора без состояния**

Итератор без состояния - это итератор, который не хранит в себе какое-либо состояние. Это позволяет нам обходится без замыканий, т.к. состояние итерации передается извне в итератор.

Пример итератора без состояния:

```lua
local function iter(a, i)
    i = i + 1
    local v = a[i]
    if v then
        return i, v
    end
end

function ipairs(a)
    return iter, a, 0
end
```

Рассмотрим реализацию функции pairs с использованием встроенной Lua функции next:

```lua
function pairs(t)
    return next, t, nil
end

for k, v in pairs(t) do
    --<...>--
end
```

Вызов next(t, k), где k - это ключ таблицы t, возвращает следующий ключ в таблице в произвольном порядке, а также связанное с этим ключом значение. Вызов next(t, nil) возвращает первую пару. Когда пар больше нет, next возвращает nil

Мы можем использовать next напрямую для того чтобы реализовать тот же функционал:

```lua
for k, v in next, t do    -- третий параметр в списке выражений будет nil
    --<...>--
end
```

***

{% hint style="warning" %}
При любой возможности вам следует пытаться написать итераторы без состояния, такие, что хранят все свое состояние в переменных цикла for. С ними вы не создаете новых объектов, когда начинаете цикл. Если для вашей итерации эта модель не подходит, то вам следует попробовать замыкания. Помимо большей изящности, замыкание обычно более эффективно, чем итератор с применением таблиц: во-первых, дешевле создать замыкание, чем таблицу; во-вторых, доступ к нелокальным переменным быстрее, чем доступ к полям таблицы. Позже мы увидим еще один способ писать итераторы, основанный на сопрограммах. Это самое эффективное решение, хотя и более затратное.
{% endhint %}

## Полезное

{% hint style="info" %}
В случае когда нужно хранить больший объем состояния, чем помещается в единственное инвариантное состояние и управляющую переменную - вы можете запаковать все, что нужно итератору, в таблицу и использовать эту таблицу как инвариантное состояние для итерации.
{% endhint %}

