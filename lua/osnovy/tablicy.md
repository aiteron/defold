---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Таблицы

Создать пустую таблицу можно следующим образом:

```
t = {}
```

Для доступа к полю таблицы используется запись вида:

имя\_переменной\[ключ]

```
t = {} -- создаем пустую таблицу
t[1] = "first" -- новое поле таблицы, с ключом 1 и значением "first"			
t[2] = 20 -- новое поле, с ключом 2 и значением 20
k = "name"
t[k] = "Jane" -- новое поле, с ключом "name" и значением "Jane"
a = t[1] -- переменная a получает значение "first"
b = t[2] -- переменная b получает значение 20
c = t["name"] -- переменная c получает значение "name"
```

В случае строковых ключей вместо записи _t\["name"]_ можно использовать запись _t.name_:

```
t.name = "name" -- эквивалентно t["name"] = "name"
a = t.name -- эквивалентно a = t["name"]
```

Выражение _t.name_ не равнозначно _t\[name]_. Первое выражение представляет поле таблицы, ключом которого является строка _"name"_ (то есть эквивалентно _t\["name"]_). Второе выражение представляет поле, ключом которого является значение переменной _name_. Различия между этими выражениями показаны в следующем примере:

```
t = {}
name = "somebody" 
t[name] = "Jane" -- в поле "somebody" помещено значение "Jane"
a = t[name] -- переменная a получает значение поля "somebody" ("Jane")
b = t.name -- поля "name" не существует, переменная b получает nil
c = t.somebody -- переменная c получает значение поля "somebody" ("Jane")
```

Если поля таблицы с заданным ключом не существует, обращение к нему дает nil:

```
t = {}
a = t.name -- переменная a получает значение nil
```

Для удаления поля таблицы достаточно присвоить ему nil:

```
t.second = nil
```

аблицу можно заполнить значениями непосредственно при создании. Для этого в фигурных скобках следует перечислить ключи и значения элементов таблицы (в формате _\[ключ]=значение_). Элементы отделяются друг от друга запятыми (,) или точками с запятой (;):

```
t = {["red"]="красный", ["green"]="зеленый", ["blue"]="синий"}
```

Приведённая запись эквивалентна следующему коду:

```
t = {}
t.red = "красный"; t.green = "зеленый"; t.blue = "синий"
```

В случае строковых ключей квадратные скобки (и двойные кавычки) можно не указывать:

```
t = {red="красный", green="зеленый", blue="синий"}
```

Если необходимо создать таблицу, поля которой также являются таблицами, это можно сделать следующим образом:

```
points = {
            a = {x=20, y=1}, 
            b = {x=40, y=2} 
         }
```

Приведённая запись эквивалентна следующему коду:

```
points = {}
p.a = {x=20, y=1}, 
p.b = {x=40, y=2}
```

\----

### Работа с массивами в Lua

Массив — это таблица, ключами которой являются целые положительные числа. Чтобы создать массив, достаточно перечислить в фигурных скобках значения его элементов:

```
t = {"красный", "зеленый", "синий"}
```

Это выражение эквивалентно следующему коду:

```
t = {[1]="красный", [2]="зеленый", [3]="синий"}
```

Обратите внимание

* В Lua массивы индексируются, начиная с 1 (а не с 0, как в некоторых языках программирования).

[Оператор получения длины #](https://www.cronos.ru/kb-1515.html), применённый к массиву, возвращает его максимальный индекс (или размер):

```
t = {"красный", "зеленый", "синий"}
n = #t -- n равно 3 
```

В примере ниже приведён ряд типичных для Lua синтаксических конструкций (идиом), основанных на использовании оператора #:

```
a = t[#t] -- присвоим переменной a значение последнего элемента массива t
t[#t] = nil -- удалим последний элемент массива t
t[#t+1] = a -- добавим значение переменной a в конец массива t
```

Обратите внимание

*   При работе с массивами следует учитывать важную особенность оператора #. Этот оператор рассматривает любой неинициализированный (имеющий значение nil) элемент массива как признак конца массива. Поэтому, например, для таблицы:

    ```
    t = {[1]="first", [3]="third"} -- элемент с индексом 2 отсутствует (t[2]==nil)
    ```

    оператор получения длины вернёт 1, а не 2 или 3. Таким образом, для корректной работы оператора # необходимо, чтобы массив не содержал «пустых» элементов.
*   Если таблица не содержит целочисленных ключей (либо элемент с индексом 1 равен nil), оператор # возвращает 0:

    ```
    t = {red="красный", green="зеленый", blue="синий"}
    n = #t -- n равно 0
    t = {[2]="красный", [3]="зеленый", [4]="синий"} 
    n = #t -- n равно 0 (поскольку t[1] имеет значение nil) 
    ```

\-----

### Обход элементов таблицы в Lua

Для обхода всех элементов таблицы обычно используют [расширенную форму оператора for](https://www.cronos.ru/kb-1526.html) совместно со [стандартной функцией pairs](https://www.cronos.ru/kb-1551.html).

```
t = { name = "Евгений",
      surname = "Степанов",
      age = 12
    }
for key, val in pairs(t) do
   MsgBox(key.." : "..val)
end
```

На каждом шаге цикла переменная key получает ключ очередного поля таблицы t, а переменная val — соответствующее ключу значение поля. Цикл выполняется по всем полям таблицы.Для обхода массива, то есть таблицы с целочисленными ключами, удобнее использовать другую [стандартную функцию Lua — ipairs](https://www.cronos.ru/kb-1551.html).

```
t = { "Иванов", "Степанов", "Петров" }
for i, val in ipairs(t) do
   MsgBox("№"..i.." : "..val)
end
```

На каждом шаге цикла переменная i получает числовой индекс очередного поля таблицы t, а переменная val — соответствующее индексу значение поля. Цикл продолжается до первого целого ключа, отсутствующего в таблице.

Примечание

*   При обходе массива необходимость в получении индекса зачастую отсутствует. В этом случае переменную i можно не вводить, заменив её символом подчеркивания (\_).

    ```
    t = { "Иванов", "Степанов", "Петров" }
    for _, val in ipairs(t) do
       MsgBox(val)
    end
    ```

Обойти массив можно и с помощью обычного [числового for](https://www.cronos.ru/kb-1526.html).

```
t = { "Иванов", "Степанов", "Петров" }
for i = 1, #t do
   MsgBox("Значение элемента №"..i.." : "..t[i])
end
```
