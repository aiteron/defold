---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Функции

## Что такое функция в Lua&#x20;

Функция в Lua является основным механизмом абстракции операторов и выражений. Проще говоря, функция - это специальная конструкция в языке которая позволяет объединить кусок кода, который выполняет определенную задачу. Это позволяет позднее использовать этот код произвольное количество раз (что позволяет избежать дублирования кода) и разделить код на достаточно простые и легко управляемые части.

## Как применять функции

Чтобы использовать функцию, нужно указать имя функции и после в круглых скобках указать аргументы что мы передаем в нее:&#x20;

```lua
print("Hello", "World")
```

Даже если мы не передаем аргументы в функцию, мы все равно должны написать () для обозначения вызова:&#x20;

```lua
foo()
```

Но если мы хотим передать в функцию только один аргумент и этот аргумент является строкой или конструктором таблицы, тогда круглые скобки можно не использовать:&#x20;

```lua
require "myscript"
sum{1, 2, 3}
```

{% hint style="warning" %}
На самом деле, когда мы говорим об имени функции, мы имеем в виду переменную, которая хранит данную функцию. Особенностью функций в Lua является то, что у них нет имен (они анонимны). Функции в Lua - это значение, обладающее теми же правами, что и традиционные значения вроде чисел и строк. Это значит, что мы можем хранить функции в переменных и таблицах, передавать функции как аргументы и возвращать их из других функций.
{% endhint %}

В случае, когда ссылка на функцию хранится в поле таблицы, имеется 2 способа вызвать функцию.&#x20;

Первый способ - использовать обращение к полю таблицы как имя функции:&#x20;

```lua
t.f()
```

Второй способ - вызов функции в объектно-ориентированном стиле. При таком вызове первым (неявным) аргументом в функцию передается таблица из которой вызывают функцию:

```lua
t:f() -- эквивалентно t.f(t)
```

***

Функции могут выполнять определенное задание (иногда называемое процедурой или подпрограммой в других языках) или вычислять и возвращать значения. В первом случае мы используем вызов функции как оператор:&#x20;

```lua
print("DUCK") 
```

Во втором случае мы можем использовать его как выражение:&#x20;

```lua
a = math.sin(3) + math.cos(10)
```

## Как определять функции

В Lua есть 2 способа определить функцию. Классическое определение выглядит следующим образом:&#x20;

```lua
function f(x,y) return x*y -- тело функции end
```

Как видно из этого примера, определение функции состоит из следующих элементов:

* ключевого слова function
* имени (f в данном примере)
* заключённого в круглые скобки списка аргументов функции
* тела функции, размещённого между закрывающей скобкой и ключевым словом end

Это определение является просто более удобным способом записи ("синтаксическим сахаром") следующего выражения:&#x20;

```lua
f = function(x,y) return x*y end
```

Таким образом, определение функции фактически выполняет два действия:

* Создаёт объект типа «функция» (это делает выражение function (x,y) ... end).
* Помещает ссылку на созданную функцию в переменную или поле таблицы (в нашем примере — в переменную f)

{% hint style="info" %}
Исходя из того, что функция в Lua является значением и в переменных хранится лишь ссылка на функцию, мы можем оперировать такими переменными как обычными переменными:

```lua
a = {p = print}
a.p("DUCK")      --> DUCK
print = math.sin -- 'print' теперь ссылается на функцию sin
a.p(print(1))    --> 0.841470
sin = a.p        -- 'sin' теперь ссылается на функцию print
sin(10, 20)      --> 10 20
```
{% endhint %}

Несмотря на то, что обычно ссылка на созданную функцию присваивается переменной, такое присваивание не является обязательным. В приведённом ниже примере создаётся безымянная функция, которая сразу передаётся в качестве параметра в функцию table.sort:&#x20;

```lua
table.sort(t, function (a, b) return (a > b) end)
```

## Параметры функции

Параметры работают в точности как другие локальные переменные внутри функции. Они создаются при входе в функцию, инициализируются значениями переданных аргументов и уничтожаются при выходе из функции. Вы можете вызвать функцию с числом аргументов, отличным от ее числа параметров. Lua приведет число аргументов к числу параметров: лишние аргументы отбрасываются, а если аргументов было меньше чем параметров, то лишние параметры получат nil.&#x20;

Пример:&#x20;

```lua
function f(a, b) print(a, b) end

f(3) --> 3 nil 
f(3, 4) --> 3 4 
f(3, 4, 5) --> 3 4
```

### Переменное количество аргументов

В Lua можно создать функцию, которая будет принимать и корректно обрабатывать переменное количество аргументов. Для этого нужно написать (...) в списке параметров функции: function add (...) local s = 0 for i, v in ipairs({...}) do s = s + v end return s end print(add(3, 4, 10, 25, 12)) --> 54 print(add(2, 2)) --> 4

Получить доступ к переданным аргументам можно с помощью выражения (...). Оно ведет себя как функция с возвратом нескольких значений (подробнее об этом ниже)

```lua
function test(...)
    print(...)
    
    local a, b = ...
    
    test2(1, 2, ...)
    
    for i, v in ipairs({...}) do
        print(i, v)
    end
    
    return ...
end

function test2(a, b, ...)
    print(a, b, ...)
end
```

### Именованные аргументы

Механизм передачи параметров в Lua является позиционным: при вызове функции аргументы сопоставляются с параметрами соответственно их позициям. Первый аргумент дает значение первому параметру и т. д. Но иногда удобно задавать аргументы по имени. В таком случае можно передавать в функцию таблицу как единственный аргумент. И в таблице указать пары ключ-значение.&#x20;

Пример:&#x20;

```lua
w = Window({x = 0, y = 0, width = 200, height = 300})

function Window(args)
    local x = args.x or 0
    local y = args.y or 0
    local width = args.width or 500
    local height = args.height or 400
    -- <DO SOME STUFF FOR CREATE WINDOW FORM>
    return windowForm
end
```

## Возврат значений из функции

В Lua функции могут возвращать любое количество значений (или не возвращать вовсе). В случае когда функция возвращает более одного значения, сохранить результат функции позволяет множественное присваивание. Примеры:

```lua
function f()
    return "A"    -- 
end

function g()
    return "B", "C", "D"
end

function h()
    print("DUCK")
end

a = f()
b, c, d = g()
h()                  --> DUCK
print(a, b, c, d)    --> A B C D
```

!! Можно использовать return чтобы раньше закончить выполнение функции. Также можно return не указывать. !! Lua всегда приводит количество результатов функции к обстоятельствам ее вызова. Когда мы вызываем функцию как оператор, Lua отбрасывает все результаты функции. Когда мы используем вызов как выражение, Lua оставляет только первый результат. Мы получаем все результаты лишь тогда, когда вызов является последним (или единственным) выражением в списке выражений. В Lua эти списки встречаются в четырех конструкциях: множественные присваивания, аргументы в вызовах функций, конструкторы таблиц и операторы return. Для иллюстрации всех этих случаев допустим, что у нас есть такие определения для наших последующих примеров:

```
function foo0() end -- возвращает 0 значений
function foo1() return "a" end -- возвращает 1 значение
function foo2() return "a", "b" end -- возвращает 2 значения
```

## Анонимные функции

В приведённом ниже примере создаётся безымянная функция, которая сразу передаётся в качестве параметра в функцию table.sort:&#x20;

```lua
table.sort(t, function (a, b) return (a > b) end)
```

## Полезное

{% hint style="info" %}
Как определить аргумент по умолчанию:

```lua
function incCount(n)
    n = n or 1
    count = count + n
end
```
{% endhint %}

\---

Когда программа вызывает функцию, управление программой передается вызываемой функции. Вызываемая функция выполняет определенную задачу, и когда выполняется оператор return или когда достигается конец ее функции, она возвращает управление программой обратно в основную программу.

\---

Программа Lua может использовать функции, написанные как на Lua, так и на С (или любом другом языке, который используется основным приложением). Например, все функции из стандартной библиотеки Lua написаны на С. Тем не менее, при вызове нет никакой разницы между функциями, определенными в Lua, и функциями, определенными в С.

\---

функции можно возвращать из функций

\---

Замыкания
