---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Функции

## Что такое функция в Lua&#x20;

Функция в Lua является основным механизмом абстракции операторов и выражений. Проще говоря, функция - это специальная конструкция в языке которая позволяет объединить кусок кода, который выполняет определенную задачу. Это позволяет позднее использовать этот код произвольное количество раз (что позволяет избежать дублирования кода) и разделить код на достаточно простые и легко управляемые части.

**Особенности функций в Lua:**

* Функции являются значениями первого класса. Это значит, что в Lua функция - это значение, обладающее теми же правами, что и традиционные значения вроде чисел, строк или таблиц. Мы можем хранить функции в переменных (локальных и глобальных) и таблицах, мы можем передавать функции как аргументы и возвращать их из других функций.
* Функции, как и другие значения, являются анонимными (у них нет имен). Когда мы говорим об имени функции, такой как print, на самом деле мы имеем в виду переменную, которая хранит данную функцию. Как и с любой другой переменной, хранящей любое другое значение, мы можем манипулировать этими переменными множеством способов.
* Функции имеют лексическую область видимости. Это значит, что функции могут обращаться к переменным объявленным вне тела этой функции в окружающем коде и не являющиеся её параметрами. Из этого следует что Lua содержит в себе полноценное лямбда-исчисление и функции могут являться замыканиями (Подробнее об этом далее в этой статье).

## Как применять функции

Для вызова функции нужно указать имя переменной или поле таблицы, что хранит ссылку на функцию и после в круглых скобках указать аргументы что мы передаем в нее (либо оставить скобки пустыми если мы не передаем аргументы):

```lua
print("Hello", "World")    --> Hello World
a = math.sin(1) + math.cos(1)
print(os.date())
```

Также существует упрощенный синтаксис вызова функции в случае когда мы передаем в функцию только один аргумент и этот аргумент является строкой или конструктором таблицы. В таком случае круглые скобки можно не использовать:

```lua
require "myscript"    --> То же самое, что и require("myscript")
sum{1, 2, 3}          --> То же самое, что и sum({1, 2, 3})
```

В Lua также существует ООП подход вызова функций, которые хранятся в поле таблицы. Для этого нужно использовать двоеточие. При таком вызове функции первым аргументом функции неявно передается таблица, в которой хранится ссылка на функцию. Подробнее об этом читайте в главе про ООП.

```lua
t:f() -- эквивалентно t.f(t)
```

### Как можно использовать вызов функции

Функции могут выполнять определенное задание (иногда называемое процедурой или подпрограммой в других языках) или вычислять и возвращать значения. В первом случае мы используем вызов функции как оператор:&#x20;

```lua
print("DUCK") 
```

Во втором случае мы можем использовать его как выражение:&#x20;

```lua
a = math.sin(3) + math.cos(10)
```

## Как определять функции

В Lua есть 2 способа определить функцию. Классическое определение выглядит следующим образом:&#x20;

```lua
function f(x,y) return x*y -- тело функции end
```

Как видно из этого примера, определение функции состоит из следующих элементов:

* ключевого слова function
* имени (f в данном примере)
* заключённого в круглые скобки списка аргументов функции
* тела функции, размещённого между закрывающей скобкой и ключевым словом end

Это определение является просто более удобным способом записи ("синтаксическим сахаром") следующего выражения:&#x20;

```lua
f = function(x,y) return x*y end
```

Таким образом, определение функции фактически выполняет два действия:

* Создаёт объект типа «функция» (это делает выражение function (x,y) ... end).
* Помещает ссылку на созданную функцию в переменную или поле таблицы (в нашем примере — в переменную f)

{% hint style="info" %}
Исходя из того, что функция в Lua является значением и в переменных хранится лишь ссылка на функцию, мы можем оперировать такими переменными как обычными переменными:

```lua
a = {p = print}
a.p("DUCK")      --> DUCK
print = math.sin -- 'print' теперь ссылается на функцию sin
a.p(print(1))    --> 0.841470
sin = a.p        -- 'sin' теперь ссылается на функцию print
sin(10, 20)      --> 10 20
```
{% endhint %}

Несмотря на то, что обычно ссылка на созданную функцию присваивается переменной, такое присваивание не является обязательным. В приведённом ниже примере создаётся анонимная (безымянная) функция, которая сразу передаётся в качестве параметра в функцию table.sort:&#x20;

```lua
table.sort(t, function (a, b) return (a > b) end)
```

## Параметры функции

Параметры работают в точности как другие локальные переменные внутри функции. Они создаются при входе в функцию, инициализируются значениями переданных аргументов и уничтожаются при выходе из функции. Вы можете вызвать функцию с числом аргументов, отличным от ее числа параметров. Lua приведет число аргументов к числу параметров: лишние аргументы отбрасываются, а если аргументов было меньше чем параметров, то лишние параметры получат nil.&#x20;

Пример:&#x20;

```lua
function f(a, b) print(a, b) end

f(3) --> 3 nil 
f(3, 4) --> 3 4 
f(3, 4, 5) --> 3 4
```

### Переменное количество аргументов

В Lua можно создать функцию, которая будет принимать и корректно обрабатывать переменное количество аргументов. Для этого нужно написать "..." в списке параметров функции

Получить доступ к переданным аргументам можно с помощью выражения "...". Оно ведет себя как функция с возвратом нескольких значений (подробнее об этом ниже)

```lua
function test(...)
    print(...)
    
    local a, b = ...
    
    test2(1, 2, ...)
    
    for i, v in ipairs({...}) do
        print(i, v)
    end
    
    return ...
end

function test2(a, b, ...)
    print(a, b, ...)
end
```

### Именованные аргументы

Механизм передачи параметров в Lua является позиционным: при вызове функции аргументы сопоставляются с параметрами соответственно их позициям. Первый аргумент дает значение первому параметру и т. д. Но иногда удобно задавать аргументы по имени. В таком случае можно передавать в функцию таблицу как единственный аргумент. И в таблице указать пары ключ-значение.&#x20;

Пример:&#x20;

```lua
w = Window{x = 0, y = 0, width = 200, height = 300}

function Window(args)
    local x = args.x or 0
    local y = args.y or 0
    local width = args.width or 500
    local height = args.height or 400
    -- <DO SOME STUFF FOR CREATE WINDOW FORM>
    return windowForm
end
```

## Возврат значений из функции

В Lua функции могут возвращать любое количество значений (или не возвращать вовсе). В случае когда функция возвращает более одного значения, сохранить результат функции позволяет множественное присваивание.&#x20;

Для того чтобы вернуть значение из функции нужно использовать ключевое слово return и после перечислить аргументы что мы хотим вернуть через запятую.

Примеры:

```lua
function f()
    return "A"
end

function g()
    return "B", "C", "D"
end

function h()
    print("DUCK")
end

a = f()
b, c, d = g()
h()                  --> DUCK
print(a, b, c, d)    --> A B C D
```

! return не обязательно указывать в функции. В случае если в функции не указано ключевое слово return, функция неявно вызывает return после выполнения всех операторов функции.

! return можно использовать только в конце блока (перед ключевым словом end). В случае если вам нужно завершить выполнение функции раньше - добавьте if end или do end блок и в нем укажите return.

Lua всегда приводит количество результатов функции к обстоятельствам ее вызова. Когда мы вызываем функцию как оператор, Lua отбрасывает все результаты функции.&#x20;

```lua
math.sin(1)    -- возвращаемое значение из функции отбросится
```

Когда мы используем вызов как выражение, Lua оставляет только первый результат.&#x20;

```lua
function test()
    return 1, 2, 3
end

print(test() + test())    --> 2
```

Мы получаем все результаты лишь тогда, когда вызов является последним (или единственным) выражением в списке выражений. В Lua эти списки встречаются в четырех конструкциях: множественные присваивания, аргументы в вызовах функций, конструкторы таблиц и операторы return. Примеры:

```lua
function foo() return "DUCK", "DOG", "BIRD" end

foo()
a1 = foo()
a2, b2 = foo()
a3, b3, c3 = foo()
a4, b4, c4, d4 = foo()

function bar(a, b, c)
    print(a, b, c)
end
bar(foo())

t = {foo()}
print(t[1])
print(t[2])
print(t[3])

function test()
    return foo()
end
print(test())
```

{% hint style="info" %}
Если количество возвращаемых функцией значений превышает число переменных, которым эти значения должны быть присвоены, «лишние» значения отбрасываются. Если возвращаемых значений меньше, чем переменных, отсутствующие значения заменяются nil
{% endhint %}



{% hint style="info" %}
Возникают ситуации, когда функция возвращает несколько значений, а переменной требуется присвоить только одно из них. Например, функция возвращает три значения, а для работы нужно только последнее: local a, b, c = f3() Как не задавать лишних имён переменных? Здесь общепринятым способом является использование переменной с именем «\_» (символом подчёркивания). Это упрощает внешний вид выражения и указывает на реально используемые переменные. local \_, \_, c = f3() -- нам нужно только третье возвращаемое значение Такой же подход часто используется в работе с итераторами: for \_, value in pairs() do print(value) -- нам нужно только очередное значение, ключ будет присвоен переменной \_ end
{% endhint %}



{% hint style="info" %}
При использовании множественного присваивания все возвращаемые функцией значения учитываются только в том случае, если вызов функции является последним (или единственным) выражением в списке выражений справа от оператора присваивания. В противном случае в присваивании участвует только одно (первое) возвращённое функцией значение. a, b, c, d = 5, f3() -- a = 5, b = 1, c = 2, d = 3 a, b, c, d = f3(), 5 -- a = 1, b = 5, c = nil, d = nil Аналогичным образом учитываются результаты вызова функции, включённого в конструктор таблицы, список аргументов другой функции и в список результатов, возвращаемых оператором return. t = {5, f3()} -- t = {5, 1, 2, 3} t = {f3(), 5} -- t = {1, 5} func (5, f3()) -- вызов функции func с аргументами 5, 1, 2, 3 func (f3(), 5) -- вызов функции func с аргументами 1, 5 return 5, f3() -- возврат значений 5, 1, 2, 3 return f3(), 5 -- возврат значений 1, 5
{% endhint %}

Возврат функций из функций Функции можно возвращать из функций. Например: function outer() function inner() return 1 end return inner end local i = outer() -- значение переменной i равно функции inner local a = i() -- вызываем функцию i, значение переменной a равно 1



\-- неглобальные функции -- Очевидным следствием того, что функции являются значениями первого класса, является то, что мы можем хранить функции не только в глобальных переменных, но и в локальных переменных и полях таблицы. Мы уже видели некоторые примеры функций внутри полей таблиц: большинство библиотек Lua использует этот механизм (например, io.read, math.sin). Для создания подобных функций в Lua нам нужно просто соединить стандартный синтаксис для функций с синтаксисом для таблиц: Lib = {}Lib.foo = function (x,y) return x + y end Lib.goo = function (x,y) return x - y end print(Lib.foo(2, 3), Lib.goo(2, 3)) --> 5 -1 Разумеется, мы также можем использовать конструкторы: Lib = { foo = function (x,y) return x + y end, goo = function (x,y) return x - y end } Кроме того, Lua предлагает еще один синтаксис для определения подобных функций: Lib = {} function Lib.foo (x,y) return x + y end function Lib.goo (x,y) return x - y end

Когда мы сохраняем функцию в локальной переменной, мы получаем локальную функцию, то есть функцию с ограниченной областью видимости. Подобные определения особенно удобны для пакетов: поскольку Lua рассматривает каждый кусок как функцию, кусок может объявлять локальные функции, которые видны только внутри него. Лексическая область видимости позволяет другим функциям из пакета использовать эти локальные функции: local f = function (<параметры>) <тело> end local g = function (<параметры>) <какой-нибудь код> f() -- 'f' здесь видима <какой-нибудь код> end Lua поощряет подобное применение локальных функций посредством синтаксическего сахара: local function f () <тело> end

При определении рекурсивных локальных функций возникает требующий уточнения момент. Дело в том, что обычный подход здесь не работает. Рассмотрим следующее определение:local fact = function (n) if n == 0 then return 1 else return n_fact(n-1) -- глюк end end Когда Lua компилирует вызов fact(n—1) в теле функции, локальная функция fact еще не определена. Поэтому данное выражение попытается вызвать глобальную функцию fact, а не локальную. Мы можем решить эту проблему, сперва определив локальную переменную, а затем уже саму функцию: local fact fact = function (n) if n == 0 then return 1 else return n_fact(n-1) end end

Теперь fact внутри функции ссылается на локальную переменную. Ее значение при определении функции не важно; к моменту выполнения функции, fact уже получит правильное значение. Когда Lua предлагает свой синтаксический сахар для локальных функций, он не использует простое определение. Вместо этого определение наподобие local function foo (<параметры>) <тело> end расширяется до local foo; foo = function (<параметры>) <тело> end Поэтому мы можем спокойно использовать этот синтаксис для рекурсивных функций.

## Замыкания

Когда мы определяем одну функцию внутри другой, она получает полный доступ к локальным переменным окружающей ее функции; мы называем это свойство лексической областью видимости (lexical scoping).Хотя это правило видимости может показаться очевидным, на самом деле это не так. Лексическая область видимости вместе с функциями первого класса является высокоэффективной концепцией в языках программирования, но многие языки ее не поддерживают.

Давайте начнем с простого примера. Пусть у вас есть список имен студентов и таблица, которая ассоциирует имена с оценками; вам требуется отсортировать список имен по их оценкам, начиная с более высоких. Вы можете добиться этого следующим образом: names = {"Peter", "Paul", "Mary"} grades = {Mary = 10, Paul = 7, Peter = 8} table.sort(names, function (n1, n2) return grades\[n1] > grades\[n2] -- сравнивает оценки end) Теперь допустим, что вам нужно создать функцию для решения данной задачи: function sortbygrade (names, grades) table.sort(names, function (n1, n2) return grades\[n1] > grades\[n2] -- сравнивает оценки end) end

Интересным моментом в этом примере является то, что анонимная функция, переданная функции sort, обращается к параметру grades, который является локальным для окружающей его функции sortbygrade. Внутри этой анонимной функции grades не является ни глобальной переменной, ни локальной переменной, а является тем, что мы называем нелокальной переменной. (По историческим причинам нелокальные переменные в Lua также называются верхними значениями (upvalue).) Почему данный момент так интересен? Потому что функции являются значениями первого класса, и вследствие этого они могут выйти из начальной области видимости своих переменных. Рассмотрим следующий пример: function newCounter () local i = 0 return function () -- анонимная функция i = i + 1 return i end end c1 = newCounter() print(c1()) --> 1print(c1()) --> 2 В этом коде анонимная функция ссылается на нелокальную переменную i для хранения своего счетчика. Однако, к тому времени, как мы вызовем анонимную функцию, переменная i уже выйдет из своей области видимости, поскольку функция, которая создала эту переменную (newCounter), уже будет возвращена. Тем не менее, Lua правильно обрабатывает эту ситуацию, используя концепцию замыкания (closure). Проще говоря, замыкание — это функция вместе со всем, что ей нужно для правильного доступа к нелокальным переменным. Если мы снова вызовем newCounter, то она создаст новую локальную переменную i, поэтому мы получим новое замыкание, действующее поверх новой переменной: c2 = newCounter() print(c2()) --> 1 print(c1()) --> 3 print(c2()) --> 2

Таким образом, c1 и с2 — это разные замыкания поверх одной и той же функции, и каждое замыкание воздействует на независимый экземпляр локальной переменной i.

Замыкания также удобны для функций обратного вызова (callback). Здесь подходит типичный пример про создание кнопок в традиционном инструментарии GUI. У каждой кнопки есть функция обратного вызова, которая должна быть вызвана, когда пользователь нажимает эту кнопку; вам требуется, чтобы разные кнопки совершали немного разные действия при нажатии. Например, цифровому калькулятору нужно десять похожих кнопок, по одной на каждую цифру. Вы можете создать каждую кнопку с помощью функции наподобие этой: function digitButton (digit)return Button{ label = tostring(digit), action = function () add\_to\_display(digit) end } end В данном примере мы предполагаем, что Button — это функция из инструментария, которая создает новые кнопки; label — это метка кнопки; action — это замыкание обратного вызова, которое нужно вызвать при нажатии кнопки. Обратный вызов может быть произведен спустя длительное время после того, как digitButton выполнила свою задачу, и после того, как локальная переменная digit вышла из области видимости, так как он по-прежнему может обращаться к этой переменной.

Замыкания также ценны в совсем другом случае. Поскольку функции Lua хранятся в обычных переменных, мы можем их легко переопределять, даже если они встроенные. Эта возможность является одной из причин, почему Lua столь гибок. Часто, когда вы переопределяете функцию, в новой реализации вам все равно нужна изначальная функция. Например, предположим, что вы хотите переопределить функцию sin, чтобы она работала с градусами вместо радиан. Эта новая функция конвертирует свой аргумент и затем вызывает исходную функцию sin для выполнения настоящей работы. Ваш код при этом может выглядеть следующим образом: oldSin = math.sin math.sin = function (x) return oldSin(x\*math.pi/180) end

Далее приведен немного более аккуратный способ выполнить это переопределение: do local oldSin = math.sin local k = math.pi/180 math.sin = function (x) return oldSin(x\*k) end end

нственный способ обратиться к ней — через новую функцию. Вы можете воспользоваться этим подходом и для созданиябезопасных окружений, также называемых песочницами (sandbox). Безопасные окружения крайне важны при выполнении ненадежного кода, например, полученного сервером через Интернет. Скажем, чтобы ограничить файлы, к которым программа может обратиться, мы можем переопределить функцию io.open, используя замыкания: do local oldOpen = io.open local access\_OK = function (filename, mode) <проверка доступа> end io.open = function (filename, mode) if access\_OK(filename, mode) then return oldOpen(filename, mode) else return nil, "access denied" end end end Что делает этот пример особенно удачным, так это то, что после данного переопределения для программы нет иного способа вызвать неограниченную функцию open, кроме как через новую версию с ограничениями. При этом небезопасная версия хранится внутри замыкания как закрытая переменная без внешнего доступа. С этим подходом вы можете строить песочницы Lua на самом Lua с его обычными преимуществами: простотой и гибкостью. Вместо какого-то универсального решения Lua предлагает мета-механизм, чтобы вы могли подогнать ваше окружение под ваши конкретные требования к безопасности.



\-- Корректные хвостовые вызовы -- Другой интересной особенностью функций в Lua является то, что Lua выполняет устранение хвостовых вызовов. (Это значит, что Lua поддерживает корректную хвостовую рекурсию, хотя данное понятие не связано непосредственно с рекурсией; см. упражнение 6.3.) Хвостовой вызов (tail call) — это фактически goto, выглядящий как вызов функции. Хвостовой вызов происходит, когда одна функция вызывает другую в качестве своего последнего действия, и потому ей больше нечего делать. Например, в следующем коде вызов функции g является хвостовым: function f (x) return g(x) end После того, как f вызовет g, ей больше нечего делать. В подобных ситуациях программе не требуется возвращаться в вызывающую функцию по завершении вызванной функции. Поэтому после хвостового вызова программе не нужно хранить какую-либо информацию о вызывающей функции в стеке. Когда g возвращает управление, оно может непосредственно перейти к моменту вызова f. Некоторые реализации языков, например, интерпретатор Lua, извлекают из данного факта выгоду и на самом деле не используют какое-либо дополнительное место в стеке при совершении хвостового вызова. Мы говорим, что эти реализации поддерживают устранение хвостовых вызовов (tail-call elimination). Поскольку хвостовые вызовы не используют место в стеке, количество вложенных хвостовых вызовов, которое программа может выполнить, не ограничено. Скажем, мы можем вызвать следующую функцию, передав любое число в качестве аргумента: function foo (n) if n > 0 then return foo(n - 1) end end Этот вызов никогда не приведет к переполнению стека. Когда мы прибегаем к устранению хвостовых вызовов, возникает тонкий вопрос: какой именно вызов считать хвостовым? Некоторые вполне очевидные кандидаты не соответствуют требованию о том, что вызывающей функции больше нечего делать после вызова. Например, в следующем коде вызов g не является хвостовым: function f (x) g(x) end Проблема в этом примере состоит в том, что после вызова g функция f должна отбросить результаты g перед возвратом. Все следующие вызовы также не удовлетворяют данному требованию: return g(x) + 1 -- необходимо выполнить сложение return x or g(x) -- необходимо привести к одному значению return (g(x)) -- необходимо привести к одному значению В Lua хвостовым считается лишь вызов вида return функция(аргументы). Однако, и функция, и ее аргументы могут быть сложными выражениями, поскольку Lua вычислит их перед вызовом. Например, следующий вызов является хвостовым: return x\[i].foo(x\[j] + a\*b, i + j)



## Полезное

{% hint style="info" %}
Как определить аргумент по умолчанию:

```lua
function incCount(n)
    n = n or 1
    count = count + n
end
```
{% endhint %}

\---

Когда программа вызывает функцию, управление программой передается вызываемой функции. Вызываемая функция выполняет определенную задачу, и когда выполняется оператор return или когда достигается конец ее функции, она возвращает управление программой обратно в основную программу.

\---

Программа Lua может использовать функции, написанные как на Lua, так и на С (или любом другом языке, который используется основным приложением). Например, все функции из стандартной библиотеки Lua написаны на С. Тем не менее, при вызове нет никакой разницы между функциями, определенными в Lua, и функциями, определенными в С.

\---&#x20;

функция unpack

Обычно unpack использует операцию длины, чтобы узнать, сколько элементов следует вернуть, поэтому она работает только с правильными последовательностями.
