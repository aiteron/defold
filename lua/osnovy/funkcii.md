---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Функции

## Что такое функция в Lua&#x20;

Функция в Lua является основным механизмом абстракции операторов и выражений. Проще говоря, функция - это специальная конструкция в языке которая позволяет объединить кусок кода, который выполняет определенную задачу. Это позволяет позднее использовать этот код произвольное количество раз (что позволяет избежать дублирования кода) и разделить код на достаточно простые и легко управляемые части.

**Особенности функций в Lua:**

* Функции являются значениями первого класса. Это значит, что в Lua функция - это значение, обладающее теми же правами, что и традиционные значения вроде чисел, строк или таблиц. Мы можем хранить функции в переменных (локальных и глобальных) и таблицах, мы можем передавать функции как аргументы и возвращать их из других функций.
* Функции, как и другие значения, являются анонимными (у них нет имен). Когда мы говорим об имени функции, такой как print, на самом деле мы имеем в виду переменную, которая хранит данную функцию. Как и с любой другой переменной, хранящей любое другое значение, мы можем манипулировать этими переменными множеством способов.
* Функции имеют лексическую область видимости. Это значит, что функции могут обращаться к переменным объявленным вне тела этой функции в окружающем коде и не являющиеся её параметрами. Из этого следует что Lua содержит в себе полноценное лямбда-исчисление и функции могут являться замыканиями (Подробнее об этом в главе [iteratory-i-zamykaniya.md](../prodvinutoe/iteratory-i-zamykaniya.md "mention")).

## Как применять функции

Для вызова функции нужно указать имя переменной или поле таблицы, что хранит ссылку на функцию и после в круглых скобках указать аргументы что мы передаем в нее (либо оставить скобки пустыми если мы не передаем аргументы):

```lua
print("Hello", "World")    --> Hello World
a = math.sin(1) + math.cos(1)
print(os.date())
```

Также существует упрощенный синтаксис вызова функции в случае когда мы передаем в функцию только один аргумент и этот аргумент является строкой или конструктором таблицы. В таком случае круглые скобки можно не использовать:

```lua
require "myscript"    --> То же самое, что и require("myscript")
sum{1, 2, 3}          --> То же самое, что и sum({1, 2, 3})
```

В Lua также существует ООП подход вызова функций, которые хранятся в поле таблицы. Для этого нужно использовать двоеточие. При таком вызове функции первым аргументом функции неявно передается таблица, в которой хранится ссылка на функцию. Подробнее об этом читайте в главе [oop-v-lua.md](oop-v-lua.md "mention").

```lua
t:f() -- эквивалентно t.f(t)
```

### Как можно использовать вызов функции

Функции могут выполнять определенное задание (иногда называемое процедурой или подпрограммой в других языках) или вычислять и возвращать значения. В первом случае мы используем вызов функции как оператор:&#x20;

```lua
print("DUCK") 
```

Во втором случае мы можем использовать его как выражение:&#x20;

```lua
a = math.sin(3) + math.cos(10)
```

## Как определять функции

В Lua есть 2 способа определить функцию. Классическое определение выглядит следующим образом:&#x20;

```lua
function f(x,y) 
    return x*y 
end
```

Как видно из этого примера, определение функции состоит из следующих элементов:

* ключевого слова function
* имени (f в данном примере)
* заключённого в круглые скобки списка аргументов функции
* тела функции, размещённого между закрывающей скобкой и ключевым словом end

Это определение является просто более удобным способом записи ("синтаксическим сахаром") следующего выражения:&#x20;

```lua
f = function(x,y) return x*y end
```

Таким образом, определение функции фактически выполняет два действия:

* Создаёт объект типа «функция» (это делает выражение function (x,y) <...> end).
* Помещает ссылку на созданную функцию в переменную или поле таблицы (в нашем примере — в переменную f)

{% hint style="info" %}
Исходя из того, что функция в Lua является значением и в переменных хранится лишь ссылка на функцию, мы можем оперировать такими переменными как обычными переменными:

```lua
a = {p = print}
a.p("DUCK")      --> DUCK
print = math.sin -- 'print' теперь ссылается на функцию sin
a.p(print(1))    --> 0.841470
sin = a.p        -- 'sin' теперь ссылается на функцию print
sin(10, 20)      --> 10 20
```
{% endhint %}

Несмотря на то, что обычно ссылка на созданную функцию присваивается переменной, такое присваивание не является обязательным. В приведённом ниже примере создаётся анонимная (безымянная) функция, которая сразу передаётся в качестве параметра в функцию table.sort:&#x20;

```lua
table.sort(t, function (a, b) return (a > b) end)
```

## Параметры функции

Параметры работают в точности как другие локальные переменные внутри функции. Они создаются при входе в функцию, инициализируются значениями переданных аргументов и уничтожаются при выходе из функции. Вы можете вызвать функцию с числом аргументов, отличным от ее числа параметров. Lua приведет число аргументов к числу параметров: лишние аргументы отбрасываются, а если аргументов было меньше чем параметров, то лишние параметры получат nil.&#x20;

Пример:&#x20;

```lua
function f(a, b) print(a, b) end

f(3) --> 3 nil 
f(3, 4) --> 3 4 
f(3, 4, 5) --> 3 4
```

### Переменное количество аргументов

В Lua можно создать функцию, которая будет принимать и корректно обрабатывать переменное количество аргументов. Для этого нужно написать "..." в списке параметров функции

Получить доступ к переданным аргументам можно с помощью выражения "...". Оно ведет себя как функция с возвратом нескольких значений (подробнее об этом ниже)

```lua
function test(...)
    print(...)
    
    local a, b = ...
    
    test2(1, 2, ...)
    
    for i, v in ipairs{...} do
        print(i, v)
    end
    
    return ...
end

function test2(a, b, ...)
    print(a, b, ...)
end
```

### Именованные аргументы

Механизм передачи параметров в Lua является позиционным: при вызове функции аргументы сопоставляются с параметрами соответственно их позициям. Первый аргумент дает значение первому параметру и т. д. Но иногда удобно задавать аргументы по имени. В таком случае можно передавать в функцию таблицу как единственный аргумент. И в таблице указать пары ключ-значение.&#x20;

Пример:&#x20;

```lua
function Window(args)
    local x = args.x or 0
    local y = args.y or 0
    local width = args.width or 500
    local height = args.height or 400
    -- <DO SOME STUFF FOR CREATE WINDOW FORM>
    return windowForm
end

w = Window{x = 0, y = 0, width = 200, height = 300}
```

## Возврат значений из функции

В Lua функции могут возвращать любое количество значений (или не возвращать вовсе). В случае когда функция возвращает более одного значения, сохранить результат функции позволяет множественное присваивание.&#x20;

Для того чтобы вернуть значение из функции нужно использовать ключевое слово return и после перечислить аргументы что мы хотим вернуть через запятую.

Примеры:

```lua
function f()
    return "A"
end

function g()
    return "B", "C", "D"
end

function h()
    print("DUCK")
end

a = f()
b, c, d = g()
h()                  --> DUCK
print(a, b, c, d)    --> A B C D
```

Lua всегда приводит количество результатов функции к обстоятельствам ее вызова. Когда мы вызываем функцию как оператор, Lua отбрасывает все результаты функции.&#x20;

```lua
math.sin(1)    -- возвращаемое значение из функции отбросится
```

Когда мы используем вызов как выражение, Lua оставляет только первый результат.&#x20;

```lua
function test()
    return 1, 2, 3
end

print(test() + test())    --> 2
```

Мы получаем все результаты лишь тогда, когда вызов является последним (или единственным) выражением в списке выражений. В Lua эти списки встречаются в четырех конструкциях: множественные присваивания, аргументы в вызовах функций, конструкторы таблиц и операторы return. Примеры:

```lua
function foo() return "DUCK", "DOG", "BIRD" end

foo()
a1 = foo()
a2, b2 = foo()
a3, b3, c3 = foo()
a4, b4, c4, d4 = foo()
print(a4, b4, c4, d4)    --> DUCK DOG BIRD nil

k1, k2, k3, k4 = foo(), 5
print(k1, k2, k3, k4)    --> DUCK, 5, nil, nil

function bar(a, b, c)
    print(a, b, c)    
end
bar(foo())               --> DUCK DOG BIRD 

t = {foo()}
print(t[1])              --> DUCK
print(t[2])              --> DOG
print(t[3])              --> BIRD

function test()
    return foo()
end
print(test())            --> DUCK DOG BIRD 
```

Если количество возвращаемых функцией значений превышает число переменных, которым эти значения должны быть присвоены, «лишние» значения отбрасываются. Если возвращаемых значений меньше, чем переменных, отсутствующие значения заменяются nil.

{% hint style="info" %}
Функции можно возвращать из функций. Например:

```lua
function foo()
    return function() print("DUCK") end
end

local f1 = foo()
f1()    --> DUCK
```
{% endhint %}

## Неглобальные функции

Т.к. функции являются значениями первого класса, мы можем хранить в переменных. В том числе и в локальных переменных (и в полях таблицы).

Когда мы сохраняем функцию в локальной переменной, мы получаем локальную функцию, то есть функцию с ограниченной областью видимости. Подобные определения особенно удобны для пакетов: поскольку Lua рассматривает каждый кусок как функцию, кусок может объявлять локальные функции, которые видны только внутри него. Подробнее в главе [moduli-i-pakety.md](moduli-i-pakety.md "mention")

Lua поощряет подобное применение локальных функций посредством синтаксического сахара:&#x20;

```lua
local function f() 
    --<...>-- 
end
```

{% hint style="warning" %}
При определении рекурсивных локальных функций возникает требующий уточнения момент.  Дело в том, что обычный подход здесь не работает. Рассмотрим следующее определение:

```lua
local fact = function(n) 
    if n == 0 then 
        return 1 
    else 
        return n*fact(n-1) -- ошибка
    end 
end
```

Когда Lua компилирует вызов fact(n—1) в теле функции, локальная функция fact еще не определена. Поэтому данное выражение попытается вызвать глобальную функцию fact, а не локальную. Мы можем решить эту проблему, сперва определив локальную переменную, а затем уже саму функцию:

```lua
local fact
fact = function(n) 
    if n == 0 then 
        return 1 
    else 
        return n*fact(n-1)
    end 
end
```

Либо мы можем использовать синтаксический сахар для определения локальных функций. При таком определении проблем с рекурсией не будет:

```lua
local function fact(n) 
    if n == 0 then 
        return 1 
    else 
        return n*fact(n-1)
    end 
end
```
{% endhint %}

## Полезное

{% hint style="info" %}
Как определить аргумент по умолчанию:

```lua
function incCount(n)
    n = n or 1
    count = count + n
end
```

Подходит для аргументов в которые не передаем false
{% endhint %}

{% hint style="info" %}
Когда программа вызывает функцию, управление программой передается вызываемой функции. Вызываемая функция выполняет определенную задачу, и когда выполняется оператор return или когда достигается конец ее функции, она возвращает управление программой обратно в основную программу.
{% endhint %}

{% hint style="info" %}
**Корректные хвостовые вызовы**

Хвостовой вызов происходит, когда одна функция вызывает другую в качестве своего последнего действия, и потому ей больше нечего делать. Например, в следующем коде вызов функции g является хвостовым:

```lua
function f (x) return g(x) end
```

После того, как f вызовет g, ей больше нечего делать. В подобных ситуациях программе не требуется возвращаться в вызывающую функцию по завершении вызванной функции. Поэтому после хвостового вызова программе не нужно хранить какую-либо информацию о вызывающей функции в стеке.

Поскольку хвостовые вызовы не используют место в стеке, количество вложенных хвостовых вызовов, которое программа может выполнить, не ограничено. Скажем, мы можем вызвать следующую функцию, передав любое число в качестве аргумента:

```lua
function foo (n)
    if n > 0 then return foo(n - 1) end
end
```

Этот вызов никогда не приведет к переполнению стека.

В Lua хвостовым считается лишь вызов вида **return функция(аргументы).**
{% endhint %}
